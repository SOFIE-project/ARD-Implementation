const truffleAssert = require('truffle-assertions');
const Registry = artifacts.require("VulnerabilityRegistry");
const RegistryTest = artifacts.require("VulnerabilityRegistryTest");

contract("VulnerabilityRegistry", function(accounts) {

    const researcher = accounts[0];
    const vendor = accounts[1];
    const authority = accounts[2];
    
    const STATUS = {
        Pending: 0,
        Invalid: 1,
        Valid: 2,
        Acknowledged: 3,
        Patched: 4,
        Disclosed: 5
    }

    const REWARDSTATE = {
        NULL: 0,
        SET: 1,
        TOCLAIM: 2,
        TOREFUND: 3,
        SENT: 4
    }

    const secret = 123;
    const hashlock = web3.utils.soliditySha3({type: 'uint', value: secret});
    const metadata = web3.utils.fromAscii(new String(13245678910)); // Random metadata in bytes32
    const bounty = web3.utils.toWei('1', 'ether');
    const vendorName = web3.utils.fromAscii("Test vendor");
    const productName = web3.utils.fromAscii("Test product");
    const productVersion = web3.utils.fromAscii("Test version");
    const vulnerabilityData = "Vulnerability detailed description in text format";
    const vulnerabilityHash = web3.utils.soliditySha3({type: 'string', value: vulnerabilityData});


    describe("Testing secret - hashlock computation", function() {

        let vulnerabilityRegistry;

        beforeEach(async function() {

            vulnerabilityRegistry = await RegistryTest.new({from: authority});
        });

        it("Should correctly create a secret-hashlock pair", async function() {

            let result = await vulnerabilityRegistry.hashlockCheck(secret, hashlock);

            assert.equal(result.hashlockComputed, hashlock, "Hashlock: Hashlock does not match with the computed one");
            assert.equal(result.equal, true, "Boolean: Hashlock does not match with the computed one");
        });
    });


    describe("Testing newVulnerability()", function() {

        let vulnerabilityRegistry;

        beforeEach(async function() {

            vulnerabilityRegistry = await RegistryTest.new({from: authority});
        });

        it("Should correctly create a a new vulnerability contract", async function() {

            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, 
                                                                    vendorName, productName,
                                                                    productVersion, vulnerabilityHash,
                                                                    {from: researcher});

            console.log(tx.receipt.gasUsed);

            // Test event fired
            truffleAssert.eventEmitted(tx, 'LogVulnerabilityNew', (ev) => {                
                return (
                        ev.researcher === researcher &&
                        ev.vendor === vendor &&
                        ev.hashlock === hashlock 
                        // TODO test metadata (problems with padded zeros from Solidity event)
                        );
            }, 'LogVulnerabilityNew event did not fire with correct parameters');

            // Get contractId from event
            let contractId = tx.receipt.logs[0].args.contractId;
            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            let metadata = await vulnerabilityRegistry.getMetadataById(contractId);
                // Check a new contract entry is correct
            assert.equal(contractData.researcher, researcher, "Researcher does not match");
            assert.equal(contractData.rewardState, REWARDSTATE.NULL, "Reward state should be NULL (0)");
            assert.equal(contractData.rewardAmount, 0, "Reward amount should be 0");
            assert.equal(contractData.status, STATUS.Pending, "Contract status should be Pending (0)");
            assert.equal(contractData.hashlock, hashlock, "Hashlock does not match");
            assert.equal(contractData.timelock, 0, "Timelock should be 0");
            assert.equal(contractData.secret, 0, "Secret should be 0");
            assert.equal(contractData.vulnerabilityLocation, "", "VulnerabilityLocation should be empty string");            
            assert.equal(metadata.vendor, vendor, "Vendor does not match");
            assert.equal(web3.utils.hexToUtf8(metadata.vendorName), web3.utils.hexToUtf8(vendorName), "VendorName does not match");
            assert.equal(web3.utils.hexToUtf8(metadata.productName), web3.utils.hexToUtf8(productName), "productName does not match");
            assert.equal(web3.utils.hexToUtf8(metadata.productVersion), web3.utils.hexToUtf8(productVersion), "productVersion does not match");
            assert.equal(metadata.vulnerabilityHash, vulnerabilityHash, "vulnerabilityHash does not match");
        });

        it("Should NOT allow the creation of two contracts with the same id", async function() {

            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, 
                                                                    vendorName, productName,
                                                                    productVersion, vulnerabilityHash,
                                                                    {from: researcher});
            
            await truffleAssert.fails(
                vulnerabilityRegistry.newVulnerability(vendor, hashlock, 
                                                        vendorName, productName,
                                                        productVersion, vulnerabilityHash,
                                                        {from: researcher}),
                truffleAssert.ErrorType.REVERT,
                "Contract already exists" // String of the revert
            );
        });

        it("Should NOT allow the creation of two contracts with the same vulnerability hash", async function() {

            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, 
                                                                    vendorName, productName,
                                                                    productVersion, vulnerabilityHash,
                                                                    {from: authority}); // different address to generate different contractId
            
            await truffleAssert.fails(
            vulnerabilityRegistry.newVulnerability(vendor, hashlock, 
                                                    vendorName, productName,
                                                    productVersion, vulnerabilityHash,
                                                    {from: researcher}),
                truffleAssert.ErrorType.REVERT,
                "Hash data already stored" // String of the revert
            );
        });
    });


    describe("Testing approve()", function() {

        let contractId;
        let vulnerabilityRegistry;

        beforeEach(async function() {

            vulnerabilityRegistry = await RegistryTest.new({from: authority});
            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, 
                                                                    vendorName, productName,
                                                                    productVersion, vulnerabilityHash,
                                                                    {from: researcher});

            contractId = tx.receipt.logs[0].args.contractId;
        });

        it("Should NOT approve a stored vulnerability: authority decision", async function() {

            let date = new Date();
            let timelock = date.getTime() + 100000; // 100K milliseconds in the future
            let tx = await vulnerabilityRegistry.approve(timelock, contractId, false, {from: authority});
    
            // Test event fired
            truffleAssert.eventEmitted(tx, 'LogVulnerabilityApproval', (ev) => {                
                return (
                        ev.timelock.toNumber() === timelock  &&
                        ev.status.toNumber() === STATUS.Invalid
                        );
            }, 'LogVulnerabilityApproval event did not fire with correct parameters');
        });

        it("Should approve a stored vulnerability", async function() {

            let date = new Date();
            let timelock = date.getTime() + 100000; // 100K milliseconds in the future
            let tx = await vulnerabilityRegistry.approve(timelock, contractId, true, {from: authority});
    
            // Test event fired
            truffleAssert.eventEmitted(tx, 'LogVulnerabilityApproval', (ev) => {                
                return (
                        ev.timelock.toNumber() === timelock  &&
                        ev.status.toNumber() === STATUS.Valid
                        );
            }, 'LogVulnerabilityApproval event did not fire with correct parameters');

            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status, STATUS.Valid, "Contract status should be Valid ("+STATUS.Valid+")");
            assert.equal(contractData.timelock, timelock, "Timelock should be " + timelock);
        });


        // The check of the authority calling is done by openzeppelin ownable -> no need to test
    });


    describe("Testing acknowledge()", function() {

        let contractId;
        let vulnerabilityRegistry;

        beforeEach(async function() {

            let date = new Date();
            let timelock = date.getTime() + 100000; // 100K milliseconds in the future
 
            vulnerabilityRegistry = await RegistryTest.new({from: authority});           
            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, 
                                                                    vendorName, productName,
                                                                    productVersion, vulnerabilityHash,
                                                                    {from: researcher});
            contractId = tx.receipt.logs[0].args.contractId;

            await vulnerabilityRegistry.approve(timelock, contractId, true, {from: authority});
        });

        it("Should acknowledge an approved vulnerability", async function() {

            let tx = await vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: bounty});
    
            // Test event fired
            truffleAssert.eventEmitted(tx, 'LogVulnerabilityAcknowledgment', (ev) => {                
                return (
                        ev.vendor === vendor  &&
                        ev.bounty.toString() === bounty.toString() // too big to use .toNumber()
                        );
            }, 'LogVulnerabilityAcknowledgment event did not fire with correct parameters');

            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status, STATUS.Acknowledged, "Contract status should be Ackowledged ("+STATUS.Acknowledged+")");
            assert.equal(contractData.rewardState, REWARDSTATE.SET, "Reward state should be SET ("+REWARDSTATE.SET+")");
            assert.equal(contractData.rewardAmount, bounty, "Reward amount should be " + bounty.toString());
        });

        it("Should NOT acknowledge an approved vulnerability: input bounty does not match the sent value", async function() {

            await truffleAssert.fails(
                vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: 12}),
                "Value sent does not match the input bounty" // String of the revert
            );
        });

        it("Should NOT acknowledge an approved vulnerability: sender is not the vendor", async function() {

            await truffleAssert.fails(
                vulnerabilityRegistry.acknowledge(contractId, bounty, {from: researcher, value: bounty}),
                "Sender is not the Vendor" // String of the revert
            );
        });

        it("Should NOT acknowledge an approved vulnerability: contract is not in a Valid state", async function() {

            await vulnerabilityRegistry.setContract(contractId, researcher, vendor, REWARDSTATE.NULL, 0,
                                                    STATUS.Invalid, // <- status, Input breaking the condition (to check)
                                                    hashlock, 0, 0, "", vulnerabilityHash);

            await truffleAssert.fails(
                vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: bounty}),
                "Status is not Valid" // String of the revert
            );
        });

        it("Should NOT acknowledge an approved vulnerability: grace period elapsed", async function() {

            await vulnerabilityRegistry.setContract(contractId, researcher, vendor, REWARDSTATE.NULL, 0, 
                                                    STATUS.Valid, hashlock, 
                                                    0, // <- timelock, Input breaking the condition (to check)
                                                    0, "", vulnerabilityHash);

            await truffleAssert.fails(
                vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: bounty}),
                "The timelock has expired" // String of the revert
            );
        });

    });

    // TODO the patch function may miss a parameter, the patch itself
    describe("Testing patch()", function() {

        let contractId;
        let vulnerabilityRegistry;

        beforeEach(async function() {

            let date = new Date();
            let timelock = date.getTime() + 100000; // 100K milliseconds in the future
 
            vulnerabilityRegistry = await RegistryTest.new({from: authority});           
             let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, 
                                                                    vendorName, productName,
                                                                    productVersion, vulnerabilityHash,
                                                                    {from: researcher});
           contractId = tx.receipt.logs[0].args.contractId;

            await vulnerabilityRegistry.approve(timelock, contractId, true, {from: authority});
            await vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: bounty});
        });

        it("Should patch an acknowledged vulnerability", async function() {

            let tx = await vulnerabilityRegistry.patch(contractId, {from: vendor});
    
            // Test event fired
            truffleAssert.eventEmitted(tx, 'LogVulnerabilityPatch', (ev) => {                
                return (
                        ev.vendor === vendor 
                        );
            }, 'LogVulnerabilityPatch event did not fire with correct parameters');

            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status, STATUS.Patched, "Contract status should be Patched ("+STATUS.Patched+")");
        });

        it("Should NOT patch an approved vulnerability: contract is not in a Valid state", async function() {

            // let bounty = web3.utils.toWei('1', 'ether');
   
            await vulnerabilityRegistry.setContract(contractId, researcher, vendor, REWARDSTATE.NULL, 0,
                                                STATUS.Invalid, // <- status, Input breaking the condition (to check)
                                                hashlock, 0, 0, "", vulnerabilityHash);

            await truffleAssert.fails(
                vulnerabilityRegistry.patch(contractId, {from: vendor}),
                "The vulnerability has not been acknowledged" // String of the revert
            );
        });

        // TODO test to store the patch data, if needed
    });


    describe("Testing approve()", function() {

        let contractId;
        let vulnerabilityRegistry;
        let date = new Date();
        let timelock = date.getTime() + 100000; // 100K milliseconds in the future

        beforeEach(async function() {
 
            vulnerabilityRegistry = await RegistryTest.new({from: authority});           
            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, 
                                                                    vendorName, productName,
                                                                    productVersion, vulnerabilityHash,
                                                                    {from: researcher});
            contractId = tx.receipt.logs[0].args.contractId;

            await vulnerabilityRegistry.approve(timelock, contractId, true, {from: authority});
            await vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: bounty});
            await vulnerabilityRegistry.patch(contractId, {from: vendor});
        });

        it("Should disclose the vulnerability: i) A patch has been provided", async function() {

            // Operation to test
            let tx = await vulnerabilityRegistry.disclose(contractId, secret, {from: researcher});
    
            // Test event fired
            truffleAssert.eventEmitted(tx, 'LogVulnerabilityDisclose', (ev) => {                
                return (
                        ev.communicator === researcher 
                        );
            }, 'LogVulnerabilityDisclose event did not fire with correct parameters');

            truffleAssert.eventEmitted(tx, 'LogVulnerabilitySecret', (ev) => {                
                return (
                        ev.secret.toNumber() === secret 
                        );
            }, 'LogVulnerabilitySecret event did not fire with correct parameters');


            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status, STATUS.Disclosed, "Contract status should be Disclosed ("+STATUS.Disclosed+")");
            assert.equal(contractData.secret, secret, "Secret does not match");
            assert.equal(contractData.rewardState, REWARDSTATE.TOCLAIM, "Contract reward state should be TOCLAIM ("+REWARDSTATE.TOCLAIM+")");
        });

        it("Should disclose the vulnerability: ii) Grace period elpased, status: Valid", async function() {

            await vulnerabilityRegistry.setContract(contractId, researcher, vendor, REWARDSTATE.NULL, 0,
                                                STATUS.Valid, // <- status, valid input
                                                hashlock,
                                                0, // <- timelock, expired
                                                0, "", vulnerabilityHash);

            let tx = await vulnerabilityRegistry.disclose(contractId, secret, {from: researcher});
    
            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status, STATUS.Disclosed, "Contract status should be Disclosed ("+STATUS.Disclosed+")");
            assert.equal(contractData.secret, secret, "Secret does not match");
        });

        it("Should disclose the vulnerability: iii) Grace period elpased, status: Acknowledged", async function() {

            await vulnerabilityRegistry.setContract(contractId, researcher, vendor, REWARDSTATE.NULL, 0,
                                                STATUS.Acknowledged, // <- status, valid input
                                                hashlock,
                                                0, // <- timelock, expired
                                                0, "", vulnerabilityHash);

            let tx = await vulnerabilityRegistry.disclose(contractId, secret, {from: researcher});
    
            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status, STATUS.Disclosed, "Contract status should be Disclosed ("+STATUS.Disclosed+")");
            assert.equal(contractData.secret, secret, "Secret does not match");
        });

        it("Should NOT disclose the vulnerability: disclosable condition not met (grace period not passed)", async function() {
            
            await vulnerabilityRegistry.setContract(contractId, researcher, vendor, REWARDSTATE.NULL, 0,
                                                STATUS.Acknowledged, // <- status, not patched
                                                hashlock,
                                                timelock, // <- timelock not expired
                                                0, "", vulnerabilityHash);

            await truffleAssert.fails(
                vulnerabilityRegistry.disclose(contractId, secret, {from: researcher}),
                "This contract cannot be discolsed" // String of the revert
            );

            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status.toNumber(), STATUS.Acknowledged, "Contract status should be Acknowledged ("+STATUS.Acknowledged+")");
            assert.equal(contractData.secret.toNumber(), 0, "Secret should be zero");
        });

        it("Should NOT disclose the vulnerability: provided incorrect secret", async function() {
            
            await truffleAssert.fails(
                vulnerabilityRegistry.disclose(contractId, 10, {from: researcher}),
                "Hashed secret and hashlock do not match" // String of the revert
            );

            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status.toNumber(), STATUS.Patched, "Contract status should be Patched ("+STATUS.Patched+")");
            assert.equal(contractData.secret.toNumber(), 0, "Secret should be zero");
        });
    });


    describe("Testing withdraw()", function() {

        let contractId;
        let vulnerabilityRegistry;
        let date = new Date();
        let timelock = date.getTime() + 100000; // 100K milliseconds in the future

        beforeEach(async function() {
 
            vulnerabilityRegistry = await RegistryTest.new({from: authority});           
            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, 
                                                                    vendorName, productName,
                                                                    productVersion, vulnerabilityHash,
                                                                    {from: researcher});
           contractId = tx.receipt.logs[0].args.contractId;

            await vulnerabilityRegistry.approve(timelock, contractId, true, {from: authority});
            await vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: bounty});
            await vulnerabilityRegistry.patch(contractId, {from: vendor});
            await vulnerabilityRegistry.disclose(contractId, secret, {from: researcher});
        });

        it("Should withdraw the bounty", async function() {

            // Operation to test
            let tx = await vulnerabilityRegistry.withdrawBounty(contractId, {from: researcher});

            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            let address = vulnerabilityRegistry.address;
            assert.equal(contractData.rewardState, REWARDSTATE.SENT, "Contract reward state should be SENT ("+REWARDSTATE.SENT+")");
            assert.equal(await web3.eth.getBalance(address), 0, "Contract balance should be zero after withdrawal");
        });

        it("Should NOT withdraw the bounty: invalid requester", async function() {

            // Operation to test
            await truffleAssert.fails(
                vulnerabilityRegistry.withdrawBounty(contractId, {from: vendor}),
                "Only the original researcher can withdraw the reward" // String of the revert
            );

            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            let address = vulnerabilityRegistry.address;
            assert.equal(contractData.rewardState, REWARDSTATE.TOCLAIM, "Contract reward state should be TOCLAIM ("+REWARDSTATE.TOCLAIM+")");
            assert.equal(await web3.eth.getBalance(address), bounty, "Contract balance should be "+bounty+" after unsuccessful withdrawal");
        });

        it("Should NOT withdraw the bounty: reward state not TOCLAIM", async function() {

            await vulnerabilityRegistry.setContract(contractId, researcher, vendor, 
                                                REWARDSTATE.SET, // <- Input arising the execption
                                                bounty, STATUS.Acknowledged, hashlock,
                                                timelock, 0, "", vulnerabilityHash);

            // Operation to test
            await truffleAssert.fails(
                vulnerabilityRegistry.withdrawBounty(contractId, {from: researcher}),
                "Cannot claim reward yet" // String of the revert
            );

            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            let address = vulnerabilityRegistry.address;
            assert.equal(contractData.rewardState, REWARDSTATE.SET, "Contract reward state should be SET ("+REWARDSTATE.SET+")");
            assert.equal(await web3.eth.getBalance(address), bounty, "Contract balance should be "+bounty+" after unsuccessful withdrawal");
        });

    });

});