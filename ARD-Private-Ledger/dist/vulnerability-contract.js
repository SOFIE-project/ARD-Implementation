"use strict";
/*
 * SPDX-License-Identifier: Apache-2.0
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VulnerabilityContract = void 0;
const crypto = require("crypto");
const fabric_contract_api_1 = require("fabric-contract-api");
const vulnerability_1 = require("./vulnerability");
const myCollectionName = 'CollectionOne';
let VulnerabilityContract = class VulnerabilityContract extends fabric_contract_api_1.Contract {
    async vulnerabilityExists(ctx, vulnerabilityId) {
        const buffer = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityId);
        return (!!buffer && buffer.length > 0);
    }
    async createVulnerability(ctx, vulnerabilityId) {
        const exists = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityId} already exists`);
        }
        const privateAsset = new vulnerability_1.Vulnerability();
        const transientData = ctx.stub.getTransient();
        if (transientData.size === 0) {
            throw new Error('The keys were not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vendorID')) {
            throw new Error('The vendorID key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorID = transientData.get('vendorID').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vendorName')) {
            throw new Error('The vendorName key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorName = transientData.get('vendorName').toString('utf8');
        if (transientData.size === 0 || !transientData.has('productName')) {
            throw new Error('The productName key was not specified in transient data. Please try again.');
        }
        privateAsset.productName = transientData.get('productName').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vulnerabilityType')) {
            throw new Error('The vulnerabilityType key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityType = transientData.get('vulnerabilityType').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vulnerabilitySeverity')) {
            throw new Error('The vulnerabilitySeverity key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilitySeverity = transientData.get('vulnerabilitySeverity').toString('utf8');
        /* if (transientData.size === 0 || !transientData.has('patchState')) {
            throw new Error('The patchState key was not specified in transient data. Please try again.');
        }
        privateAsset.patchState = transientData.get('patchState').toString('utf8');*/
        if (transientData.size === 0 || !transientData.has('gracePeriod')) {
            throw new Error('The gracePeriod key was not specified in transient data. Please try again.');
        }
        privateAsset.gracePeriod = transientData.get('gracePeriod').toString('utf8');
        if (transientData.size === 0 || !transientData.has('bountyAmount')) {
            throw new Error('The bountyAmount key was not specified in transient data. Please try again.');
        }
        privateAsset.bountyAmount = transientData.get('bountyAmount').toString('utf8');
        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(privateAsset)));
    }
    async readVulnerability(ctx, vulnerabilityId) {
        const exists = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);
        }
        let privateDataString;
        const privateData = await ctx.stub.getPrivateData(myCollectionName, vulnerabilityId);
        privateDataString = JSON.parse(privateData.toString());
        return privateDataString;
    }
    /* @Transaction()
    public async updateVulnerability(ctx: Context, vulnerabilityId: string, patchSt: string): Promise<void> {
        const exists: boolean = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);
        }
        // const privateData: Buffer = await ctx.stub.getPrivateData(myCollectionName, vulnerabilityId);
        // let privateDataString: string;
        // privateDataString = JSON.parse(privateData.toString());
        let privateAsset: Vulnerability = new Vulnerability();
        const result = this.readVulnerability(ctx, vulnerabilityId);
        privateAsset=JSON.parse(JSON.stringify(result));

        // const transientData: Map<string, Buffer> = ctx.stub.getTransient();
        // if (transientData.size === 0 || !transientData.has('privateValue')) {
        // throw new Error('The privateValue key was not specified in transient data. Please try again.');
        // }
        // privateAsset.privateValue = transientData.get('privateValue').toString('utf8');
        privateAsset.patchState=patchSt;
        console.log(privateAsset);
        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(privateAsset)));
    }*/
    async updateVulnerability(ctx, vulnerabilityId) {
        const exists = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);
        }
        const privateAsset = new vulnerability_1.Vulnerability();
        const transientData = ctx.stub.getTransient();
        if (transientData.size === 0 || !transientData.has('vendorID')) {
            throw new Error('The vendorID key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vendorName')) {
            throw new Error('The vendorName key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('productName')) {
            throw new Error('The productName key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilityType')) {
            throw new Error('The vulnerabilityType key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilitySeverity')) {
            throw new Error('The vulnerabilitySeverity key was not specified in transient data. Please try again.');
        }
        /* if (transientData.size === 0 || !transientData.has('patchState')) {
            throw new Error('The patchState key was not specified in transient data. Please try again.');
        }*/
        if (transientData.size === 0 || !transientData.has('gracePeriod')) {
            throw new Error('The gracePeriod key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('bountyAmount')) {
            throw new Error('The bountyAmount key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorID = transientData.get('vendorID').toString('utf8');
        privateAsset.vendorName = transientData.get('vendorName').toString('utf8');
        privateAsset.productName = transientData.get('productName').toString('utf8');
        privateAsset.vulnerabilityType = transientData.get('vulnerabilityType').toString('utf8');
        privateAsset.vulnerabilitySeverity = transientData.get('vulnerabilitySeverity').toString('utf8');
        // privateAsset.patchState = transientData.get('patchState').toString('utf8');
        privateAsset.gracePeriod = transientData.get('gracePeriod').toString('utf8');
        privateAsset.bountyAmount = transientData.get('bountyAmount').toString('utf8');
        console.log(privateAsset);
        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(privateAsset)));
    }
    async deleteVulnerability(ctx, vulnerabilityId) {
        const exists = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);
        }
        await ctx.stub.deletePrivateData(myCollectionName, vulnerabilityId);
    }
    async verifyVulnerability(ctx, vulnerabilityId, objectToVerify) {
        // Convert user provided object into a hash
        const hashToVerify = crypto.createHash('sha256').update(JSON.stringify(objectToVerify)).digest('hex');
        const pdHashBytes = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityId);
        if (pdHashBytes.length === 0) {
            throw new Error(`No private data hash with the Key: ${vulnerabilityId}`);
        }
        const actualHash = pdHashBytes.toString('hex');
        // Compare the hash calculated (from object provided) and the hash stored on public ledger
        if (hashToVerify === actualHash) {
            return true;
        }
        else {
            return false;
        }
    }
    // data-sender.ts
    interledgerAbort(ctx) {
        return null;
    }
    interledgerCommit(ctx) {
        return null;
    }
    async emitData(ctx, data) {
        const id = JSON.stringify(ctx.stub.getState('id'));
        let id1 = parseInt(id, 10);
        id1 += 1;
        const iles = {
            Id: JSON.stringify(id1),
            Data: JSON.stringify(data)
        };
        await ctx.stub.putState('id', Buffer.from(JSON.stringify(id1)));
        ctx.stub.setEvent('InterledgerEventSending', Buffer.from(JSON.stringify(iles)));
        return null;
    }
    // data-receiver.ts
    /* @Transaction()
    @Returns('Vulnerability')
    public async interledgerReceive(ctx: Context,nonceString: string, secretData: string):Promise<string> {

        // const args = this.newMethod(secretID);
        // let nonce_bytes=JSON.stringify(args[0]);
        // let secretID = args[1];
        const middle = Math.ceil(secretData.length / 2);
        const patchState = secretData.slice(0, middle);
        const vulnerabilityId = secretData.slice(middle);
        const res = this.vulnerabilityExists(ctx, vulnerabilityId);

        if(!res)
        {
            throw new Error('Invalid Secret');
        }
        const lastChar = patchState.substr(patchState.length-1);

        // let returnString:string = JSON.stringify(result);

        if(lastChar==='1')
        {
            // result=JSON.parse((JSON.stringify(result)).replace('"patchState":"Not Patched"','"patchState":"Patched"'));
            const ctx2: Context = this.createContext();
            this.updateVulnerability(ctx2, vulnerabilityId,'Patched');
            // ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(returnString))
        }
        // console.log(result);
        // console.dir(result.payload.toString('utf8'));
        // console.log(result.toString());
        // const returnValue: string = VulnerabilityContract.upload(result.toString());
        // const nonce = parseInt(nonceString, 64);
        let result = this.readVulnerability(ctx, vulnerabilityId);
        if(lastChar==='1')
        {
            result=JSON.parse((JSON.stringify(result)).replace('"patchState":"Not Patched"','"patchState":"Patched"'));
        }
        const nonce = nonceString;

        const dataItem : DataItem ={
            Nonce : nonce,
            Data: vulnerabilityId
        };

        // let items: Array<DataItem>;
        // items.push(dataItem);

        ctx.stub.putState('items',Buffer.from(JSON.stringify(dataItem)));
        ctx.stub.setEvent('InterledgerEventAccepted', Buffer.from(JSON.stringify(nonce)));

        this.emitData(ctx, result);

        return result;

    }

    @Transaction()
    public async updatePatchState(ctx:Context, vulnerabilityId: string, patchSt: string):Promise<void> {

        const exists: boolean = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);
        }
        let privateAsset: Vulnerability = new Vulnerability();
        privateAsset.patchState=patchSt;
        console.log(privateAsset);
        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(privateAsset)));
    }*/
    async interledgerReceive(ctx, nonceString, secretData) {
        // const middle = Math.ceil(secretData.length / 2);
        // const patchState = secretData.slice(0, middle);
        const vulnerabilityId = secretData;
        const res = this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!res) {
            throw new Error('Invalid Secret');
        }
        // const lastChar = patchState.substr(patchState.length-1);
        // let returnString:string = JSON.stringify(result);
        /* if(lastChar==='1')
        {
            const transientMap: Map<string, Buffer> = new Map<string, Buffer>();
            const asset: Vulnerability = JSON.parse(await this.readVulnerability(ctx, vulnerabilityId));
            transientMap.set('vendorID', Buffer.from(asset.vendorID));
            transientMap.set('vendorName', Buffer.from(asset.vendorName));
            transientMap.set('productName', Buffer.from(asset.productName));
            transientMap.set('vulnerabilityType', Buffer.from(asset.vulnerabilityType));
            transientMap.set('vulnerabilitySeverity', Buffer.from(asset.vulnerabilitySeverity));
            transientMap.set('patchState', Buffer.from('Patched'));
            transientMap.set('bountyAmount', Buffer.from(asset.bountyAmount));

            ctx.stub.getTransient.returns(transientMap);
            await this.updateVulnerability(ctx, '001');

        }*/
        // let result:string;
        const result = this.readVulnerability(ctx, vulnerabilityId);
        /* if(lastChar === '1'){
            console.log(`Please update patchState to Patched for vulnerability: ${vulnerabilityId}`);
            // this.updatePatchState(ctx,vulnerabilityId,"Patched");
            returnValue = result.toString().replace('Not Patched','Patched');
            console.log(returnValue);
        }*/
        const nonce = nonceString;
        const dataItem = {
            Nonce: nonce,
            Data: vulnerabilityId
        };
        // let items: Array<DataItem>;
        // items.push(dataItem);
        await ctx.stub.putState('items', Buffer.from(JSON.stringify(dataItem)));
        ctx.stub.setEvent('InterledgerEventAccepted', Buffer.from(JSON.stringify(nonce)));
        this.emitData(ctx, result);
        return result;
    }
};
__decorate([
    fabric_contract_api_1.Transaction(false),
    fabric_contract_api_1.Returns('boolean'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "vulnerabilityExists", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "createVulnerability", null);
__decorate([
    fabric_contract_api_1.Transaction(false),
    fabric_contract_api_1.Returns('Vulnerability'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "readVulnerability", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "updateVulnerability", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "deleteVulnerability", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String, vulnerability_1.Vulnerability]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "verifyVulnerability", null);
__decorate([
    fabric_contract_api_1.Transaction(false),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context]),
    __metadata("design:returntype", Error)
], VulnerabilityContract.prototype, "interledgerAbort", null);
__decorate([
    fabric_contract_api_1.Transaction(false),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context]),
    __metadata("design:returntype", Error)
], VulnerabilityContract.prototype, "interledgerCommit", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, Promise]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "emitData", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    fabric_contract_api_1.Returns('Vulnerability'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "interledgerReceive", null);
VulnerabilityContract = __decorate([
    fabric_contract_api_1.Info({ title: 'VulnerabilityContract', description: 'My Private Data Smart Contract' })
], VulnerabilityContract);
exports.VulnerabilityContract = VulnerabilityContract;
//# sourceMappingURL=vulnerability-contract.js.map