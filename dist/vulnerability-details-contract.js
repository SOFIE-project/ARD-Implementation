"use strict";
/*
 * SPDX-License-Identifier: Apache-2.0
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const fabric_contract_api_1 = require("fabric-contract-api");
const vulnerability_details_1 = require("./vulnerability-details");
const myCollectionName = 'CollectionOne';
let VulnerabilityDetailsContract = class VulnerabilityDetailsContract extends fabric_contract_api_1.Contract {
    async vulnerabilityDetailsExists(ctx, vulnerabilityDetailsId) {
        const buffer = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityDetailsId);
        return (!!buffer && buffer.length > 0);
    }
    async createVulnerabilityDetails(ctx, vulnerabilityDetailsId) {
        const exists = await this.vulnerabilityDetailsExists(ctx, vulnerabilityDetailsId);
        if (exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityDetailsId} already exists`);
        }
        const privateAsset = new vulnerability_details_1.VulnerabilityDetails();
        const transientData = ctx.stub.getTransient();
        if (transientData.size === 0 || !transientData.has('vendorID')) {
            throw new Error('The vendorID key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorID = transientData.get('vendorID').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vendorName')) {
            throw new Error('The vendorName key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorName = transientData.get('vendorName').toString('utf8');
        if (transientData.size === 0 || !transientData.has('productName')) {
            throw new Error('The productName key was not specified in transient data. Please try again.');
        }
        privateAsset.productName = transientData.get('productName').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vulnerabilityType')) {
            throw new Error('The vulnerabilityType key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityType = transientData.get('vulnerabilityType').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vulnerabilitySeverity')) {
            throw new Error('The vulnerabilitySeverity key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilitySeverity = transientData.get('vulnerabilitySeverity').toString('utf8');
        if (transientData.size === 0 || !transientData.has('patchState')) {
            throw new Error('The patchState key was not specified in transient data. Please try again.');
        }
        privateAsset.patchState = transientData.get('patchState').toString('utf8');
        if (transientData.size === 0 || !transientData.has('gracePeriod')) {
            throw new Error('The gracePeriod key was not specified in transient data. Please try again.');
        }
        privateAsset.gracePeriod = transientData.get('gracePeriod').toString('utf8');
        if (transientData.size === 0 || !transientData.has('bountyAmount')) {
            throw new Error('The bountyAmount key was not specified in transient data. Please try again.');
        }
        privateAsset.bountyAmount = transientData.get('bountyAmount').toString('utf8');
        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityDetailsId, Buffer.from(JSON.stringify(privateAsset)));
    }
    async readVulnerabilityDetails(ctx, vulnerabilityDetailsId) {
        const exists = await this.vulnerabilityDetailsExists(ctx, vulnerabilityDetailsId);
        if (!exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityDetailsId} does not exist`);
        }
        let privateDataString;
        const privateData = await ctx.stub.getPrivateData(myCollectionName, vulnerabilityDetailsId);
        privateDataString = JSON.parse(privateData.toString());
        return privateDataString;
    }
    async updateVulnerabilityDetails(ctx, vulnerabilityDetailsId) {
        const exists = await this.vulnerabilityDetailsExists(ctx, vulnerabilityDetailsId);
        if (!exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityDetailsId} does not exist`);
        }
        const privateAsset = new vulnerability_details_1.VulnerabilityDetails();
        const transientData = ctx.stub.getTransient();
        if (transientData.size === 0 || !transientData.has('patchState')) {
            throw new Error('The patchState key was not specified in transient data. Please try again.');
        }
        privateAsset.patchState = transientData.get('patchState').toString('utf8');
        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityDetailsId, Buffer.from(JSON.stringify(privateAsset)));
    }
    async deleteVulnerabilityDetails(ctx, vulnerabilityDetailsId) {
        const exists = await this.vulnerabilityDetailsExists(ctx, vulnerabilityDetailsId);
        if (!exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityDetailsId} does not exist`);
        }
        await ctx.stub.deletePrivateData(myCollectionName, vulnerabilityDetailsId);
    }
    async verifyVulnerabilityDetails(ctx, vulnerabilityDetailsId, objectToVerify) {
        // Convert user provided object into a hash
        const hashToVerify = crypto.createHash('sha256').update(JSON.stringify(objectToVerify)).digest('hex');
        const pdHashBytes = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityDetailsId);
        if (pdHashBytes.length === 0) {
            throw new Error(`No private data hash with the Key: ${vulnerabilityDetailsId}`);
        }
        const actualHash = pdHashBytes.toString('hex');
        // Compare the hash calculated (from object provided) and the hash stored on public ledger
        if (hashToVerify === actualHash) {
            return true;
        }
        else {
            return false;
        }
    }
};
__decorate([
    fabric_contract_api_1.Transaction(false),
    fabric_contract_api_1.Returns('boolean'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityDetailsContract.prototype, "vulnerabilityDetailsExists", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityDetailsContract.prototype, "createVulnerabilityDetails", null);
__decorate([
    fabric_contract_api_1.Transaction(false),
    fabric_contract_api_1.Returns('VulnerabilityDetails'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityDetailsContract.prototype, "readVulnerabilityDetails", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityDetailsContract.prototype, "updateVulnerabilityDetails", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityDetailsContract.prototype, "deleteVulnerabilityDetails", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String, vulnerability_details_1.VulnerabilityDetails]),
    __metadata("design:returntype", Promise)
], VulnerabilityDetailsContract.prototype, "verifyVulnerabilityDetails", null);
VulnerabilityDetailsContract = __decorate([
    fabric_contract_api_1.Info({ title: 'VulnerabilityDetailsContract', description: 'ARD Private Vulnerability Details Smart Contract' })
], VulnerabilityDetailsContract);
exports.VulnerabilityDetailsContract = VulnerabilityDetailsContract;
//# sourceMappingURL=vulnerability-details-contract.js.map