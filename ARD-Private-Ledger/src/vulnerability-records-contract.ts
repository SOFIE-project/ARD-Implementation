/*
 * SPDX-License-Identifier: Apache-2.0
 */

import crypto = require('crypto');
import { Context, Contract, Info, Returns, Transaction } from 'fabric-contract-api';
import { VulnerabilityRecords } from './vulnerability-records';
import abi = require('ethereumjs-abi');
import Cloudant = require('@cloudant/cloudant');

// const me = 'IBMid-5500091BVJ'; // Set this to your own account.
// const password = 'IBMCloud4!';
// Initialize the library with my account.
// const cloudant = Cloudant({ account: me, password: password});
// const cloudant = Cloudant({ url: 'https://f1ab26d4-7cce-4f62-bbe9-df56b09ed5bc-bluemix.cloudantnosqldb.appdomain.cloud', plugins: { iamauth: { iamApiKey: 'VL_2K5Md6KREIenEg-GW9IhvRGJmLXB8URqB86TtGkky' } } });
const cloudant = Cloudant({ url: 'https://d402b46a-a6dc-493a-aa24-955795f7a190-bluemix:b421adb6be6386bd98c22c1cc7a3158f229ee9bf34b1fbf84960b002ae0a3f7d@d402b46a-a6dc-493a-aa24-955795f7a190-bluemix.cloudantnosqldb.appdomain.cloud', plugins: { iamauth: { iamApiKey: 'WfB8MGZXD3jKgfl06mOuAvjs2J3iqjAv8esWyCsq6b-4' } } });
const myCollectionName: string = 'CollectionOne';

// data-receiver.ts
type InterledgerEventAccepted = {
    Nonce: string;
};

type InterledgerEventRejected = {
    Nonce: string;
};

type DataItem = {
    Nonce: string;
    Data: string;
};
interface InterledgerReceiver{
    interledgerReceive(ctx: Context, nonce: string, secretIDData: string):Promise<string>;// Function to receive data from Interledger
}

// data-sender.ts
type InterledgerEventSending = {
    Id: string;
    Data: string;
};

interface InterledgerSender{
    interledgerCommit(ctx: Context):Error;
    interledgerAbort(ctx: Context):Error;
}

@Info({title: 'VulnerabilityRecordsContract', description: 'My Private Data Smart Contract' })
export class VulnerabilityRecordsContract extends Contract implements InterledgerReceiver, InterledgerSender{

    @Transaction(false)
    @Returns('boolean')
    public async vulnerabilityRecordsExists(ctx: Context, vulnerabilityRecordsId: string): Promise<boolean> {
        const buffer: Buffer = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityRecordsId);
        return (!!buffer && buffer.length > 0);
    }

    @Transaction()
    public async createVulnerabilityRecords(ctx: Context, vulnerabilityRecordsId: string): Promise<void> {
        const exists: boolean = await this.vulnerabilityRecordsExists(ctx, vulnerabilityRecordsId);
        if (exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityRecordsId} already exists`);
        }

        const privateAsset: VulnerabilityRecords = new VulnerabilityRecords();

        const transientData: Map<string, Buffer> = ctx.stub.getTransient();

        if(transientData.size === 0) {
            throw new Error('The keys were not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilityID')) {
            throw new Error('The vulnerabilityID key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityID = transientData.get('vulnerabilityID').toString('utf8');
        const id = parseInt(privateAsset.vulnerabilityID, 10);

        if (transientData.size === 0 || !transientData.has('vendorID')) {
            throw new Error('The vendorID key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorID = transientData.get('vendorID').toString('utf8');

        if (transientData.size === 0 || !transientData.has('vendorName')) {
            throw new Error('The vendorName key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorName = transientData.get('vendorName').toString('utf8');

        if (transientData.size === 0 || !transientData.has('productName')) {
            throw new Error('The productName key was not specified in transient data. Please try again.');
        }
        privateAsset.productName = transientData.get('productName').toString('utf8');

        if (transientData.size === 0 || !transientData.has('vulnerabilityType')) {
            throw new Error('The vulnerabilityType key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityType = transientData.get('vulnerabilityType').toString('utf8');

        if (transientData.size === 0 || !transientData.has('vulnerabilitySeverity')) {
            throw new Error('The vulnerabilitySeverity key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilitySeverity = transientData.get('vulnerabilitySeverity').toString('utf8');

        if (transientData.size === 0 || !transientData.has('vulnerabilityPath')) {
            throw new Error('The vulnerabilityPath key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityPath = transientData.get('vulnerabilityPath').toString('utf8');

        if (transientData.size === 0 || !transientData.has('vulnerabilityDesc')) {
            throw new Error('The vulnerabilityDesc key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityDesc = transientData.get('vulnerabilityDesc').toString('utf8');

        if (transientData.size === 0 || !transientData.has('gracePeriod')) {
            throw new Error('The gracePeriod key was not specified in transient data. Please try again.');
        }
        privateAsset.gracePeriod = transientData.get('gracePeriod').toString('utf8');

        if (transientData.size === 0 || !transientData.has('approvedOn')) {
            throw new Error('The approvedOn key was not specified in transient data. Please try again.');
        }
        privateAsset.approvedOn = transientData.get('approvedOn').toString('utf8');

        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityRecordsId, Buffer.from(JSON.stringify(privateAsset)));
        const abiApprovePass = '0x'+abi.rawEncode(['int','bool'],[id, true]).toString('hex');
        console.log('Approval transferred to Public Ledger via Interledger Component:\n');
        console.log(abiApprovePass);
        ctx.stub.setEvent('InterledgerEventSending', Buffer.from(abiApprovePass));

    }

    @Transaction(false)
    @Returns('VulnerabilityRecords')
    public async readVulnerabilityRecords(ctx: Context, vulnerabilityRecordsId: string): Promise<string> {
        const exists: boolean = await this.vulnerabilityRecordsExists(ctx, vulnerabilityRecordsId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityRecordsId} does not exist`);
        }

        let privateDataString: string;
        const privateData: Buffer = await ctx.stub.getPrivateData(myCollectionName, vulnerabilityRecordsId);

        privateDataString = JSON.parse(privateData.toString());
        // console.log(privateDataString);
        return privateDataString;
    }

    @Transaction()
    public async updateVulnerabilityRecords(ctx: Context, vulnerabilityRecordsId: string): Promise<void> {
        const exists: boolean = await this.vulnerabilityRecordsExists(ctx, vulnerabilityRecordsId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityRecordsId} does not exist`);
        }
        const privateAsset: VulnerabilityRecords = new VulnerabilityRecords();
        const transientData: Map<string, Buffer> = ctx.stub.getTransient();

        if(transientData.size === 0) {
            throw new Error('The keys were not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilityID')) {
            throw new Error('The vulnerabilityID key was not specified in transient data. Please try again.');
       }
        if (transientData.size === 0 || !transientData.has('vendorID')) {
             throw new Error('The vendorID key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vendorName')) {
             throw new Error('The vendorName key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('productName')) {
            throw new Error('The productName key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilityType')) {
            throw new Error('The vulnerabilityType key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilitySeverity')) {
            throw new Error('The vulnerabilitySeverity key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilityPath')) {
            throw new Error('The vulnerabilityPath key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilityDesc')) {
            throw new Error('The vulnerabilityDesc key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('gracePeriod')) {
            throw new Error('The gracePeriod key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('approvedOn')) {
            throw new Error('The approvedOn key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityID = transientData.get('vulnerabilityID').toString('utf8');
        privateAsset.vendorID = transientData.get('vendorID').toString('utf8');
        privateAsset.vendorName = transientData.get('vendorName').toString('utf8');
        privateAsset.productName = transientData.get('productName').toString('utf8');
        privateAsset.vulnerabilityType = transientData.get('vulnerabilityType').toString('utf8');
        privateAsset.vulnerabilitySeverity = transientData.get('vulnerabilitySeverity').toString('utf8');
        privateAsset.vulnerabilityPath = transientData.get('vulnerabilityPath').toString('utf8');
        privateAsset.vulnerabilityDesc = transientData.get('vulnerabilityDesc').toString('utf8');
        privateAsset.gracePeriod = transientData.get('gracePeriod').toString('utf8');
        privateAsset.approvedOn = transientData.get('approvedOn').toString('utf8');
        // console.log(privateAsset);
        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityRecordsId, Buffer.from(JSON.stringify(privateAsset)));
    }

    @Transaction()
    public async deleteVulnerabilityRecords(ctx: Context, vulnerabilityRecordsId: string): Promise<void> {
        const exists: boolean = await this.vulnerabilityRecordsExists(ctx, vulnerabilityRecordsId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityRecordsId} does not exist`);
        }
        await ctx.stub.deletePrivateData(myCollectionName, vulnerabilityRecordsId);
    }

    @Transaction()
    public async verifyVulnerabilityRecords(ctx: Context, vulnerabilityRecordsId: string, objectToVerify: VulnerabilityRecords): Promise<boolean> {
        // Convert user provided object into a hash
        const hashToVerify: string = crypto.createHash('sha256').update(JSON.stringify(objectToVerify)).digest('hex');
        const pdHashBytes: Buffer = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityRecordsId);
        if (pdHashBytes.length === 0) {
            throw new Error(`No private data hash with the Key: ${vulnerabilityRecordsId}`);
        }

        const actualHash: string = pdHashBytes.toString('hex');

        // Compare the hash calculated (from object provided) and the hash stored on public ledger
        if (hashToVerify === actualHash) {
            return true;
        } else {
            return false;
        }
    }
    // data-sender.ts
    @Transaction(false)
    interledgerAbort(ctx:Context): Error{
        return null;
    }

    @Transaction(false)
    interledgerCommit(ctx:Context): Error{
        return null;
    }

    /* @Transaction()
    public async asyncCall() {
        await cloudant.db.create('VulnerabilityRecords');
    }*/

    @Transaction()
    public async emitData(ctx:Context, vulnerabilityID: string, data:string): Promise<Error>{
        const iles : InterledgerEventSending ={
            Id : vulnerabilityID,
            Data: data
        };
        await ctx.stub.putState('id', Buffer.from(vulnerabilityID));
        const vulnerabilityIDPass = Number(vulnerabilityID);
        // const passDataString = vulnerabilityID + data;
        // const passData = Buffer.from(passDataString).toString('base64');
        const abiPass = '0x'+abi.rawEncode(['int','string'],[vulnerabilityIDPass, data]).toString('hex');
        console.log('Data transferred to Public Ledger via Interledger Component:\n');
        console.log(abiPass);
        ctx.stub.setEvent('InterledgerEventSending', Buffer.from(abiPass));
        return null;
    }

    // data-receiver.ts
    @Transaction()
    @Returns('Vulnerability')
    public async interledgerReceive(ctx: Context, nonceString: string, secretIDDataBytes: string):Promise<string> {

        console.log('Data received from Public Ledger via Interledger Component\n');
        console.log(secretIDDataBytes);
        const middle = Math.ceil(secretIDDataBytes.length / 2);
        const secretIDString = secretIDDataBytes.slice(0, middle+1);
        // console.log(secretIDString);
        const vulIdString = secretIDDataBytes.slice(middle+1);
        // console.log(vulIdString);
        const secretID = parseInt(secretIDString, 16).toString(10);
        const vulnerabilityID = parseInt(vulIdString, 16).toString(10);
        // console.log(`vulnerability id: ${vulnerabilityID}`);
        const nonce = nonceString;
        const res = this.vulnerabilityRecordsExists(ctx, secretID);// JSON Obj

        if(!res)
        {
            ctx.stub.setEvent('InterledgerEventRejected', Buffer.from(JSON.stringify(nonce)));
            throw new Error(`The asset vulnerability ${secretID} does not exist`);
        }
        const result = await this.readVulnerabilityRecords(ctx, secretID);
        console.log('Full Vulnerability Information for Secret:\n');
        console.log(result);
        // await cloudant.db.create(secretID);
        cloudant.use('database-vulnerability').insert(result, vulnerabilityID);
        console.log('Data Inserted Successfully');

        const dataItem : DataItem = {
            Nonce : nonce,
            Data: secretID
        };

        await ctx.stub.putState('items',Buffer.from(JSON.stringify(dataItem)));
        ctx.stub.setEvent('InterledgerEventAccepted', Buffer.from(JSON.stringify(nonce)));
        const urlString='https://d402b46a-a6dc-493a-aa24-955795f7a190-bluemix.cloudantnosqldb.appdomain.cloud/database-vulnerability/_design/show_example/_show/Beu/'+vulnerabilityID;
        console.log(urlString);
        this.emitData(ctx, vulnerabilityID, urlString);
        return result;

    }


}
