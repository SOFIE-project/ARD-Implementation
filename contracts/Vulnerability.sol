pragma solidity ^0.6.0;

// Remix only
// import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title VulnerabilityRegistry
 *
 * @notice This contract supports responsible disclosure of vulnerabilities. For each vulnerability a state machine identifies the stage of the responsible disclosure process
 *
 *
 */
contract VulnerabilityRegistry is Ownable {

    // Logs
    event LogVulnerabilityNew(
        bytes32 indexed contractId,
        address indexed researcher,
        address indexed vendor,
        bytes32 hashlock,
        bytes32 metadata
        );
    event LogVulnerabilityApproval(
        bytes32 indexed contractId,
        uint timelock,
        Status status
    );
    event LogVulnerabilitySecret(bytes32 indexed contractId, uint secret);
    event LogVulnerabilityAcknowledgment(bytes32 indexed contractId, address indexed vendor, uint bounty);
    event LogVulnerabilityPatch(bytes32 indexed contractId, address indexed vendor);
    event LogVulnerabilityDisclose(bytes32 indexed contractId, address indexed communicator);

    // States

    enum Status {Pending, Invalid, Valid, Acknowledged, Patched, Disclosed}
    enum RewardState {NULL, SET, TOCLAIM, TOREFUND, SENT} // TODO evaluate if we need TOREFUND

    // Structs

    struct Reward {
        RewardState state;
        uint amount;
    }

    struct VulnerabilityContract {
        address payable researcher;
        address vendor;
        Reward reward;
        Status status;
        bytes32 hashlock;               // Sha-2 sha256 the secret used as hashlock
        uint timelock;                  // UNIX timestamp seconds - locked UNTIL this time //deadline
        uint secret;                 // The secret
        string vulnerabilityLocation;   // A pointer to a location with the vulnerability information
                                        // TODO this includes also the patch?
        // bytes data; // The vulnerability data
        // bytes patch; // The patch data
    }

    // Maps

    mapping (bytes32 => VulnerabilityContract) Contracts; //mapping _contract_id => _vulnerability
    mapping (bytes32 => bytes32) Meta; //mapping _hashIpfsMetadata => _contract_id

    // Modifiers

    modifier fundsSent() {
        require(msg.value > 0, "msg.value must be > 0");
        _;
    }
    modifier futureTimelock(uint _time) {
        // The timelock time is after the last blocktime (now).
        // TODO probably want something a bit further in the future then this.
            // but this is still a useful sanity check:
        require(_time > now, "timelock time must be in the future");
        _;
    }
    modifier contractExists(bytes32 _contractId) {
        require(haveContract(_contractId), "contractId does not exist");
        _;
    }
    modifier hashlockMatches(bytes32 _contractId, uint _secret) {
        require(
            // TODO choose hash function
            Contracts[_contractId].hashlock == keccak256(abi.encodePacked(_secret)),
            "Hashed secret and hashlock do not match"
        );
        _;
    }
    modifier disclosable(bytes32 _contractId) {
        // Check the condition to disclose a vulnerability
        require(isDisclosable(_contractId), "This contract cannot be discolsed");
        _;
    }
    modifier isValid(bytes32 _contractId) {
        // Check whether a contract is Valid, i.e. it has been approved
        require(Contracts[_contractId].status == Status.Valid, "Status is not Valid");
        _;
    }
    modifier isVendor(bytes32 _contractId) {
        require(Contracts[_contractId].vendor == msg.sender, "Sender is not the Vendor");
        _;
    }


    /**
     * @dev The resercher sets up a new vulnerability contract.
     *
     * @param _vendor The Vendor address, the owner of the vulnerable device
     * @param _hashlock The secret hash used also for the hashlock (sha-2 sha256).
     * @param _vulnerabilityMetadata The vulnerability metadata.
     *
     * @return contractId Id of the new contract. This is needed for subsequent calls.
     */
    function newVulnerability(address _vendor, bytes32 _hashlock, bytes32 _vulnerabilityMetadata)
        external
        returns (bytes32 contractId)
    {
        contractId = keccak256(
            abi.encodePacked(
                msg.sender,
                _vendor,
                _hashlock,
                _vulnerabilityMetadata
            )
        );

        // Reject if a contract already exists with the same parameters. The
        // sender must change one of these parameters to create a new distinct
        // contract.
        if (haveContract(contractId))
            revert("Contract already exists");

        if (haveMeta(_vulnerabilityMetadata)) {
            // TODO ... meanwhile revert//
            revert("Meta already exists");
        }

        // Store the new vulnerability entry
        Reward memory reward = Reward({amount: 0, state: RewardState.NULL});

        Contracts[contractId] = VulnerabilityContract({
            vendor: _vendor,
            researcher: msg.sender,
            reward: reward,
            hashlock: _hashlock,
            timelock: 0,
            vulnerabilityLocation: "",
            status: Status.Pending,
            secret: 0
        });

        // Associate the contract with the vulnerability metadata

        Meta[_vulnerabilityMetadata] = contractId;

        emit LogVulnerabilityNew(
            contractId,
            msg.sender,
            _vendor,
            _hashlock,
            _vulnerabilityMetadata
        );

        return contractId;
    }


    /**
     * @dev The authority approves the vulnerability contract and provides the lock terms.
     *
     * @param _timelock UNIX epoch seconds time that  lock expires at.
     * @param _contractId The condract identifier.
     * @param _approved The approval parameter.
     */
    function approve(uint _timelock, bytes32 _contractId, bool _approved)
        external
        onlyOwner()
        futureTimelock(_timelock)
        contractExists(_contractId)
    {
        VulnerabilityContract storage c = Contracts[_contractId];

        // Reject if the contract isn't aprroved (the verification is off chain)

        if (!_approved) {
            c.status = Status.Invalid;
        }
        else {
            c.timelock = _timelock;
            c.status = Status.Valid;
        }

         emit LogVulnerabilityApproval(
            _contractId,
            _timelock,
            c.status
        );
    }

    /**
     * @dev The vendor acknowledges the vulnerability and sends ETH as a reward for the researcher.
     *
     * @param _contractId The condract identifier.
     * @param _bounty The bounty ETH.
     */
    function acknowledge(bytes32 _contractId, uint _bounty) 
        external
        payable
        fundsSent()
        contractExists(_contractId)
        isValid(_contractId) 
        isVendor(_contractId) {

        VulnerabilityContract storage c = Contracts[_contractId];

        require(now < c.timelock, "The timelock has expired");
        require(msg.value == _bounty, "Value sent does not match the input bounty");

        c.status = Status.Acknowledged;
        c.reward.state = RewardState.SET;
        c.reward.amount = _bounty;

        emit LogVulnerabilityAcknowledgment(_contractId, msg.sender, _bounty);
    }

    /**
     * @dev The vendor provides a patch to the vulnerability.
     *
     * @param _contractId The condract identifier.
     */
    function patch(bytes32 _contractId) external contractExists(_contractId) isVendor(_contractId) {

        VulnerabilityContract storage c = Contracts[_contractId];

        require(c.status == Status.Acknowledged, "The vulnerability has not been acknowledged");
        // TODO check grace period ?

        c.status = Status.Patched;
        // TODO store patch data
        emit LogVulnerabilityPatch(_contractId, msg.sender);
    }


     /**
     * @dev Called by who knows the secret (the researcher or the authority).
     * This will allow the researcher to withdraw the bounty.
     *
     * @param _contractId Id of the VulnerabilityContract.
     * @param _secret The preimage of the hashlock
     */
    function disclose(bytes32 _contractId, uint _secret)
        external
        contractExists(_contractId)
        disclosable(_contractId)
        hashlockMatches(_contractId, _secret)
        
        returns (bool success)
    {

        VulnerabilityContract storage c = Contracts[_contractId];

        // TODO What if the bounty has not been set? keep it NULL
        c.reward.state = RewardState.TOCLAIM;
        c.secret = _secret;
        c.status = Status.Disclosed;

        // TODO store vulnerability data location

        emit LogVulnerabilityDisclose(_contractId, msg.sender);
        emit LogVulnerabilitySecret(_contractId, _secret);
        success = true;
    }

     /**
     * @dev Withdraw the bounty 
     *
     * @param _contractId Id of the VulnerabilityContract.
     */
    function withdrawBounty(bytes32 _contractId) external {

        VulnerabilityContract storage c = Contracts[_contractId];

        require(c.reward.state == RewardState.TOCLAIM, "Cannot claim reward yet");
        require(msg.sender == c.researcher, "Only the original researcher can withdraw the reward");

        c.reward.state = RewardState.SENT;
        c.researcher.transfer(c.reward.amount);
    }

    /**
     * @dev Get contract details.
     * @param _contractId contract id
     */
    function getContractById(bytes32 _contractId)
        public
        view
        returns (
            address payable researcher,
            address vendor,
            RewardState rewardState,
            uint rewardAmount,
            Status status,
            bytes32 hashlock,
            uint timelock,
            uint secret,
            string memory vulnerabilityLocation
        )
    {
        if (haveContract(_contractId) == false)
            return (address(0), address(0), RewardState.NULL, 0, Status.Pending, 0x0, 0, 0, "");
        
        VulnerabilityContract storage c = Contracts[_contractId];
        return (
            c.researcher,
            c.vendor,
            c.reward.state,
            c.reward.amount,
            c.status,
            c.hashlock,
            c.timelock,
            c.secret,
            c.vulnerabilityLocation
        );
    }

    /**
     * @dev Is there a contract with id _contractId.
     * @param _contractId Id into contracts mapping.
     */
    function haveContract(bytes32 _contractId)
        internal
        view
        returns (bool exists)
    {
        exists = (Contracts[_contractId].researcher != address(0));
    }

    /**
     * @dev Is there a contract with meta _meta.
     * @param _hashIpfsMetadata the metadata of the VulnerabilityContract.
     */
    function haveMeta(bytes32 _hashIpfsMetadata)
        internal
        view
        returns (bool exists)
    {
        exists = (Meta[_hashIpfsMetadata] != 0x0);
    }

    /**
     * @dev Is the input contract disclosable
     * @param _contractId Contract identifier
     */
    function isDisclosable(bytes32 _contractId) public view returns(bool) {

        VulnerabilityContract storage c = Contracts[_contractId];
        return  ((c.status == Status.Valid || c.status == Status.Acknowledged) && c.timelock < now) ||
                (c.status == Status.Patched);

    }

}
