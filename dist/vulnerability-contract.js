"use strict";
/*
 * SPDX-License-Identifier: Apache-2.0
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const fabric_contract_api_1 = require("fabric-contract-api");
const vulnerability_1 = require("./vulnerability");
const myCollectionName = 'CollectionOne';
;
;
let VulnerabilityContract = class VulnerabilityContract extends fabric_contract_api_1.Contract {
    async vulnerabilityExists(ctx, vulnerabilityId) {
        const buffer = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityId);
        return (!!buffer && buffer.length > 0);
    }
    async createVulnerability(ctx, vulnerabilityId) {
        const exists = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityId} already exists`);
        }
        const privateAsset = new vulnerability_1.Vulnerability();
        const transientData = ctx.stub.getTransient();
        if (transientData.size === 0 || !transientData.has('vendorID')) {
            throw new Error('The vendorID key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorID = transientData.get('vendorID').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vendorName')) {
            throw new Error('The vendorName key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorName = transientData.get('vendorName').toString('utf8');
        if (transientData.size === 0 || !transientData.has('productName')) {
            throw new Error('The productName key was not specified in transient data. Please try again.');
        }
        privateAsset.productName = transientData.get('productName').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vulnerabilityType')) {
            throw new Error('The vulnerabilityType key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityType = transientData.get('vulnerabilityType').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vulnerabilitySeverity')) {
            throw new Error('The vulnerabilitySeverity key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilitySeverity = transientData.get('vulnerabilitySeverity').toString('utf8');
        if (transientData.size === 0 || !transientData.has('patchState')) {
            throw new Error('The patchState key was not specified in transient data. Please try again.');
        }
        privateAsset.patchState = transientData.get('patchState').toString('utf8');
        if (transientData.size === 0 || !transientData.has('gracePeriod')) {
            throw new Error('The gracePeriod key was not specified in transient data. Please try again.');
        }
        privateAsset.gracePeriod = transientData.get('gracePeriod').toString('utf8');
        if (transientData.size === 0 || !transientData.has('bountyAmount')) {
            throw new Error('The bountyAmount key was not specified in transient data. Please try again.');
        }
        privateAsset.bountyAmount = transientData.get('bountyAmount').toString('utf8');
        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(privateAsset)));
    }
    async readVulnerability(ctx, vulnerabilityId) {
        const exists = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);
        }
        let privateDataString;
        const privateData = await ctx.stub.getPrivateData(myCollectionName, vulnerabilityId);
        privateDataString = JSON.parse(privateData.toString());
        return privateDataString;
    }
    async updateVulnerability(ctx, vulnerabilityId, patchSt) {
        const exists = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);
        }
        //const privateData: Buffer = await ctx.stub.getPrivateData(myCollectionName, vulnerabilityId);
        //let privateDataString: string;
        //privateDataString = JSON.parse(privateData.toString());
        let privateAsset = new vulnerability_1.Vulnerability();
        const result = this.readVulnerability(ctx, vulnerabilityId);
        privateAsset = JSON.parse(JSON.stringify(result));
        //const transientData: Map<string, Buffer> = ctx.stub.getTransient();
        //if (transientData.size === 0 || !transientData.has('privateValue')) {
        //  throw new Error('The privateValue key was not specified in transient data. Please try again.');
        //}
        //privateAsset.privateValue = transientData.get('privateValue').toString('utf8');
        privateAsset.patchState = patchSt;
        console.log(privateAsset);
        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(privateAsset)));
    }
    async deleteVulnerability(ctx, vulnerabilityId) {
        const exists = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);
        }
        await ctx.stub.deletePrivateData(myCollectionName, vulnerabilityId);
    }
    async verifyVulnerability(ctx, vulnerabilityId, objectToVerify) {
        // Convert user provided object into a hash
        const hashToVerify = crypto.createHash('sha256').update(JSON.stringify(objectToVerify)).digest('hex');
        const pdHashBytes = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityId);
        if (pdHashBytes.length === 0) {
            throw new Error(`No private data hash with the Key: ${vulnerabilityId}`);
        }
        const actualHash = pdHashBytes.toString('hex');
        // Compare the hash calculated (from object provided) and the hash stored on public ledger
        if (hashToVerify === actualHash) {
            return true;
        }
        else {
            return false;
        }
    }
    //data-sender.ts
    interledgerAbort(ctx) {
        return null;
    }
    interledgerCommit(ctx) {
        return null;
    }
    async emitData(ctx, data) {
        let id = JSON.stringify(ctx.stub.getState("id"));
        let id1 = parseInt(id);
        id1 += 1;
        var iles = {
            Id: JSON.stringify(id1),
            Data: JSON.stringify(data)
        };
        ctx.stub.putState("id", Buffer.from(JSON.stringify(id1)));
        ctx.stub.setEvent("InterledgerEventSending", Buffer.from(JSON.stringify(iles)));
        return null;
    }
    //data-receiver.ts
    async interledgerReceive(ctx, nonceString, secretData) {
        //const args = this.newMethod(secretID);
        //var nonce_bytes=JSON.stringify(args[0]);
        //var secretID = args[1];
        var middle = Math.ceil(secretData.length / 2);
        var patchState = secretData.slice(0, middle);
        var vulnerabilityId = secretData.slice(middle);
        const res = this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!res) {
            throw new Error("Invalid Secret");
        }
        var lastChar = patchState.substr(patchState.length - 1);
        //var returnString:string = JSON.stringify(result);
        if (lastChar == '1') {
            //result=JSON.parse((JSON.stringify(result)).replace('"patchState":"Not Patched"','"patchState":"Patched"'));
            let ctx2 = this.createContext();
            this.updateVulnerability(ctx2, vulnerabilityId, "Patched");
            //ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(returnString))   
        }
        //console.log(result);
        //console.dir(result.payload.toString('utf8'));
        //console.log(result.toString());
        //const returnValue: string = VulnerabilityContract.upload(result.toString());
        //const nonce = parseInt(nonceString, 64);
        let result = this.readVulnerability(ctx, vulnerabilityId);
        if (lastChar == '1') {
            result = JSON.parse((JSON.stringify(result)).replace('"patchState":"Not Patched"', '"patchState":"Patched"'));
        }
        const nonce = nonceString;
        var dataItem = {
            Nonce: nonce,
            Data: vulnerabilityId
        };
        //var items: Array<DataItem>;
        //items.push(dataItem);
        ctx.stub.putState("items", Buffer.from(JSON.stringify(dataItem)));
        ctx.stub.setEvent("InterledgerEventAccepted", Buffer.from(JSON.stringify(nonce)));
        this.emitData(ctx, result);
        return result;
    }
};
__decorate([
    fabric_contract_api_1.Transaction(false),
    fabric_contract_api_1.Returns('boolean'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "vulnerabilityExists", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "createVulnerability", null);
__decorate([
    fabric_contract_api_1.Transaction(false),
    fabric_contract_api_1.Returns('Vulnerability'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "readVulnerability", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "updateVulnerability", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "deleteVulnerability", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String, vulnerability_1.Vulnerability]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "verifyVulnerability", null);
__decorate([
    fabric_contract_api_1.Transaction(false),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context]),
    __metadata("design:returntype", Error)
], VulnerabilityContract.prototype, "interledgerAbort", null);
__decorate([
    fabric_contract_api_1.Transaction(false),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context]),
    __metadata("design:returntype", Error)
], VulnerabilityContract.prototype, "interledgerCommit", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, Promise]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "emitData", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    fabric_contract_api_1.Returns('Vulnerability'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityContract.prototype, "interledgerReceive", null);
VulnerabilityContract = __decorate([
    fabric_contract_api_1.Info({ title: 'VulnerabilityContract', description: 'My Private Data Smart Contract' })
], VulnerabilityContract);
exports.VulnerabilityContract = VulnerabilityContract;
//# sourceMappingURL=vulnerability-contract.js.map