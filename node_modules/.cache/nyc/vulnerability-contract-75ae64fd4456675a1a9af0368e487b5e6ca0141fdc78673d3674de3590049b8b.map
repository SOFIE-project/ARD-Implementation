{"version":3,"file":"/home/prateeti/SOFIE-private-ledger/vulnerability-private-data-collections/src/vulnerability-contract.ts","sources":["/home/prateeti/SOFIE-private-ledger/vulnerability-private-data-collections/src/vulnerability-contract.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport crypto = require('crypto');\nimport { Context, Contract, Info, Returns, Transaction } from 'fabric-contract-api';\nimport { contracts } from '.';\nimport { Vulnerability } from './vulnerability';\nconst myCollectionName: string = 'CollectionOne';\n\n\n// data-receiver.ts\ntype InterledgerEventAccepted = {\n    Nonce: string;\n};\n\ntype InterledgerEventRejected = {\n    Nonce: string;\n};\n\n\ntype DataItem = {\n    Nonce: string;\n    Data: string;\n};\ninterface InterledgerReceiver{\n    interledgerReceive(ctx: Context, nonce: string, secretData: string):Promise<string>;// Function to receive data from Interledger\n}\n// data-sender.ts\ntype InterledgerEventSending = {\n    Id: string;\n    Data: string;\n};\n\ninterface InterledgerSender{\n    interledgerCommit(ctx: Context):Error;\n    interledgerAbort(ctx: Context):Error;\n}\n\n@Info({title: 'VulnerabilityContract', description: 'My Private Data Smart Contract' })\nexport class VulnerabilityContract extends Contract implements InterledgerReceiver, InterledgerSender{\n\n    @Transaction(false)\n    @Returns('boolean')\n    public async vulnerabilityExists(ctx: Context, vulnerabilityId: string): Promise<boolean> {\n        const buffer: Buffer = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityId);\n        return (!!buffer && buffer.length > 0);\n    }\n\n    @Transaction()\n    public async createVulnerability(ctx: Context, vulnerabilityId: string): Promise<void> {\n        const exists: boolean = await this.vulnerabilityExists(ctx, vulnerabilityId);\n        if (exists) {\n            throw new Error(`The asset vulnerability details ${vulnerabilityId} already exists`);\n        }\n\n        const privateAsset: Vulnerability = new Vulnerability();\n\n        const transientData: Map<string, Buffer> = ctx.stub.getTransient();\n\n        if(transientData.size === 0) {\n            throw new Error('The keys were not specified in transient data. Please try again.');\n        }\n        if (transientData.size === 0 || !transientData.has('vendorID')) {\n            throw new Error('The vendorID key was not specified in transient data. Please try again.');\n        }\n        privateAsset.vendorID = transientData.get('vendorID').toString('utf8');\n\n        if (transientData.size === 0 || !transientData.has('vendorName')) {\n            throw new Error('The vendorName key was not specified in transient data. Please try again.');\n        }\n        privateAsset.vendorName = transientData.get('vendorName').toString('utf8');\n\n        if (transientData.size === 0 || !transientData.has('productName')) {\n            throw new Error('The productName key was not specified in transient data. Please try again.');\n        }\n        privateAsset.productName = transientData.get('productName').toString('utf8');\n\n        if (transientData.size === 0 || !transientData.has('vulnerabilityType')) {\n            throw new Error('The vulnerabilityType key was not specified in transient data. Please try again.');\n        }\n        privateAsset.vulnerabilityType = transientData.get('vulnerabilityType').toString('utf8');\n\n        if (transientData.size === 0 || !transientData.has('vulnerabilitySeverity')) {\n            throw new Error('The vulnerabilitySeverity key was not specified in transient data. Please try again.');\n        }\n        privateAsset.vulnerabilitySeverity = transientData.get('vulnerabilitySeverity').toString('utf8');\n\n        /* if (transientData.size === 0 || !transientData.has('patchState')) {\n            throw new Error('The patchState key was not specified in transient data. Please try again.');\n        }\n        privateAsset.patchState = transientData.get('patchState').toString('utf8');*/\n        if (transientData.size === 0 || !transientData.has('gracePeriod')) {\n            throw new Error('The gracePeriod key was not specified in transient data. Please try again.');\n        }\n        privateAsset.gracePeriod = transientData.get('gracePeriod').toString('utf8');\n\n        if (transientData.size === 0 || !transientData.has('bountyAmount')) {\n            throw new Error('The bountyAmount key was not specified in transient data. Please try again.');\n        }\n        privateAsset.bountyAmount = transientData.get('bountyAmount').toString('utf8');\n\n        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(privateAsset)));\n    }\n\n    @Transaction(false)\n    @Returns('Vulnerability')\n    public async readVulnerability(ctx: Context, vulnerabilityId: string): Promise<string> {\n        const exists: boolean = await this.vulnerabilityExists(ctx, vulnerabilityId);\n        if (!exists) {\n            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);\n        }\n\n        let privateDataString: string;\n        const privateData: Buffer = await ctx.stub.getPrivateData(myCollectionName, vulnerabilityId);\n\n        privateDataString = JSON.parse(privateData.toString());\n        return privateDataString;\n    }\n\n    /* @Transaction()\n    public async updateVulnerability(ctx: Context, vulnerabilityId: string, patchSt: string): Promise<void> {\n        const exists: boolean = await this.vulnerabilityExists(ctx, vulnerabilityId);\n        if (!exists) {\n            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);\n        }\n        // const privateData: Buffer = await ctx.stub.getPrivateData(myCollectionName, vulnerabilityId);\n        // let privateDataString: string;\n        // privateDataString = JSON.parse(privateData.toString());\n        let privateAsset: Vulnerability = new Vulnerability();\n        const result = this.readVulnerability(ctx, vulnerabilityId);\n        privateAsset=JSON.parse(JSON.stringify(result));\n\n        // const transientData: Map<string, Buffer> = ctx.stub.getTransient();\n        // if (transientData.size === 0 || !transientData.has('privateValue')) {\n        // throw new Error('The privateValue key was not specified in transient data. Please try again.');\n        // }\n        // privateAsset.privateValue = transientData.get('privateValue').toString('utf8');\n        privateAsset.patchState=patchSt;\n        console.log(privateAsset);\n        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(privateAsset)));\n    }*/\n\n    @Transaction()\n    public async updateVulnerability(ctx: Context, vulnerabilityId: string): Promise<void> {\n        const exists: boolean = await this.vulnerabilityExists(ctx, vulnerabilityId);\n        if (!exists) {\n            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);\n        }\n        const privateAsset: Vulnerability = new Vulnerability();\n        const transientData: Map<string, Buffer> = ctx.stub.getTransient();\n        if (transientData.size === 0 || !transientData.has('vendorID')) {\n             throw new Error('The vendorID key was not specified in transient data. Please try again.');\n        }\n        if (transientData.size === 0 || !transientData.has('vendorName')) {\n             throw new Error('The vendorName key was not specified in transient data. Please try again.');\n        }\n        if (transientData.size === 0 || !transientData.has('productName')) {\n            throw new Error('The productName key was not specified in transient data. Please try again.');\n        }\n        if (transientData.size === 0 || !transientData.has('vulnerabilityType')) {\n            throw new Error('The vulnerabilityType key was not specified in transient data. Please try again.');\n        }\n        if (transientData.size === 0 || !transientData.has('vulnerabilitySeverity')) {\n            throw new Error('The vulnerabilitySeverity key was not specified in transient data. Please try again.');\n        }\n        /* if (transientData.size === 0 || !transientData.has('patchState')) {\n            throw new Error('The patchState key was not specified in transient data. Please try again.');\n        }*/\n        if (transientData.size === 0 || !transientData.has('gracePeriod')) {\n            throw new Error('The gracePeriod key was not specified in transient data. Please try again.');\n        }\n        if (transientData.size === 0 || !transientData.has('bountyAmount')) {\n            throw new Error('The bountyAmount key was not specified in transient data. Please try again.');\n        }\n\n        privateAsset.vendorID = transientData.get('vendorID').toString('utf8');\n        privateAsset.vendorName = transientData.get('vendorName').toString('utf8');\n        privateAsset.productName = transientData.get('productName').toString('utf8');\n        privateAsset.vulnerabilityType = transientData.get('vulnerabilityType').toString('utf8');\n        privateAsset.vulnerabilitySeverity = transientData.get('vulnerabilitySeverity').toString('utf8');\n        // privateAsset.patchState = transientData.get('patchState').toString('utf8');\n        privateAsset.gracePeriod = transientData.get('gracePeriod').toString('utf8');\n        privateAsset.bountyAmount = transientData.get('bountyAmount').toString('utf8');\n        console.log(privateAsset);\n        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(privateAsset)));\n    }\n\n\n    @Transaction()\n    public async deleteVulnerability(ctx: Context, vulnerabilityId: string): Promise<void> {\n        const exists: boolean = await this.vulnerabilityExists(ctx, vulnerabilityId);\n        if (!exists) {\n            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);\n        }\n        await ctx.stub.deletePrivateData(myCollectionName, vulnerabilityId);\n    }\n\n    @Transaction()\n    public async verifyVulnerability(ctx: Context, vulnerabilityId: string, objectToVerify: Vulnerability): Promise<boolean> {\n        // Convert user provided object into a hash\n        const hashToVerify: string = crypto.createHash('sha256').update(JSON.stringify(objectToVerify)).digest('hex');\n        const pdHashBytes: Buffer = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityId);\n        if (pdHashBytes.length === 0) {\n            throw new Error(`No private data hash with the Key: ${vulnerabilityId}`);\n        }\n\n        const actualHash: string = pdHashBytes.toString('hex');\n\n        // Compare the hash calculated (from object provided) and the hash stored on public ledger\n        if (hashToVerify === actualHash) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n\n    // data-sender.ts\n\n    @Transaction(false)\n    interledgerAbort(ctx:Context): Error{\n        return null;\n    }\n\n    @Transaction(false)\n    interledgerCommit(ctx:Context): Error{\n        return null;\n    }\n\n    @Transaction()\n    public async emitData(ctx:Context, data:Promise<string>): Promise<Error>{\n\n        const id = JSON.stringify(ctx.stub.getState('id'));\n        let id1 = parseInt(id,10);\n        id1+=1;\n        const iles : InterledgerEventSending ={\n            Id : JSON.stringify(id1),\n            Data: JSON.stringify(data)\n        };\n\n        await ctx.stub.putState('id', Buffer.from(JSON.stringify(id1)));\n        // ctx.stub.setEvent('InterledgerEventSending', Buffer.from(JSON.stringify(iles)));\n\n        return null;\n    }\n\n    // data-receiver.ts\n\n    /* @Transaction()\n    @Returns('Vulnerability')\n    public async interledgerReceive(ctx: Context,nonceString: string, secretData: string):Promise<string> {\n\n        // const args = this.newMethod(secretID);\n        // let nonce_bytes=JSON.stringify(args[0]);\n        // let secretID = args[1];\n        const middle = Math.ceil(secretData.length / 2);\n        const patchState = secretData.slice(0, middle);\n        const vulnerabilityId = secretData.slice(middle);\n        const res = this.vulnerabilityExists(ctx, vulnerabilityId);\n\n        if(!res)\n        {\n            throw new Error('Invalid Secret');\n        }\n        const lastChar = patchState.substr(patchState.length-1);\n\n        // let returnString:string = JSON.stringify(result);\n\n        if(lastChar==='1')\n        {\n            // result=JSON.parse((JSON.stringify(result)).replace('\"patchState\":\"Not Patched\"','\"patchState\":\"Patched\"'));\n            const ctx2: Context = this.createContext();\n            this.updateVulnerability(ctx2, vulnerabilityId,'Patched');\n            // ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(returnString))\n        }\n        // console.log(result);\n        // console.dir(result.payload.toString('utf8'));\n        // console.log(result.toString());\n        // const returnValue: string = VulnerabilityContract.upload(result.toString());\n        // const nonce = parseInt(nonceString, 64);\n        let result = this.readVulnerability(ctx, vulnerabilityId);\n        if(lastChar==='1')\n        {\n            result=JSON.parse((JSON.stringify(result)).replace('\"patchState\":\"Not Patched\"','\"patchState\":\"Patched\"'));\n        }\n        const nonce = nonceString;\n\n        const dataItem : DataItem ={\n            Nonce : nonce,\n            Data: vulnerabilityId\n        };\n\n        // let items: Array<DataItem>;\n        // items.push(dataItem);\n\n        ctx.stub.putState('items',Buffer.from(JSON.stringify(dataItem)));\n        ctx.stub.setEvent('InterledgerEventAccepted', Buffer.from(JSON.stringify(nonce)));\n\n        this.emitData(ctx, result);\n\n        return result;\n\n    }\n\n    @Transaction()\n    public async updatePatchState(ctx:Context, vulnerabilityId: string, patchSt: string):Promise<void> {\n\n        const exists: boolean = await this.vulnerabilityExists(ctx, vulnerabilityId);\n        if (!exists) {\n            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);\n        }\n        let privateAsset: Vulnerability = new Vulnerability();\n        privateAsset.patchState=patchSt;\n        console.log(privateAsset);\n        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(privateAsset)));\n    }*/\n\n    @Transaction()\n    @Returns('Vulnerability')\n    public async interledgerReceive(ctx: Context,nonceString: string, secretData: string):Promise<string> {\n\n        // const middle = Math.ceil(secretData.length / 2);\n        // const patchState = secretData.slice(0, middle);\n        const vulnerabilityId = secretData;\n        const res = this.vulnerabilityExists(ctx, vulnerabilityId);\n\n        if(!res)\n        {\n            throw new Error('Invalid Secret');\n        }\n        // const lastChar = patchState.substr(patchState.length-1);\n\n        // let returnString:string = JSON.stringify(result);\n\n        /* if(lastChar==='1')\n        {\n            const transientMap: Map<string, Buffer> = new Map<string, Buffer>();\n            const asset: Vulnerability = JSON.parse(await this.readVulnerability(ctx, vulnerabilityId));\n            transientMap.set('vendorID', Buffer.from(asset.vendorID));\n            transientMap.set('vendorName', Buffer.from(asset.vendorName));\n            transientMap.set('productName', Buffer.from(asset.productName));\n            transientMap.set('vulnerabilityType', Buffer.from(asset.vulnerabilityType));\n            transientMap.set('vulnerabilitySeverity', Buffer.from(asset.vulnerabilitySeverity));\n            transientMap.set('patchState', Buffer.from('Patched'));\n            transientMap.set('bountyAmount', Buffer.from(asset.bountyAmount));\n\n            ctx.stub.getTransient.returns(transientMap);\n            await this.updateVulnerability(ctx, '001');\n\n        }*/\n        // let result:string;\n        const result = this.readVulnerability(ctx, vulnerabilityId);\n        /* if(lastChar === '1'){\n            console.log(`Please update patchState to Patched for vulnerability: ${vulnerabilityId}`);\n            // this.updatePatchState(ctx,vulnerabilityId,\"Patched\");\n            returnValue = result.toString().replace('Not Patched','Patched');\n            console.log(returnValue);\n        }*/\n\n        const nonce = nonceString;\n        const dataItem : DataItem = {\n            Nonce : nonce,\n            Data: vulnerabilityId\n        };\n\n        // let items: Array<DataItem>;\n        // items.push(dataItem);\n\n        await ctx.stub.putState('items',Buffer.from(JSON.stringify(dataItem)));\n        ctx.stub.setEvent('InterledgerEventAccepted', Buffer.from(JSON.stringify(nonce)));\n\n        this.emitData(ctx, result);\n\n        return result;\n\n    }\n\n\n}\n"]}