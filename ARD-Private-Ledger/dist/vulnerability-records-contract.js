"use strict";
/*
 * SPDX-License-Identifier: Apache-2.0
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const fabric_contract_api_1 = require("fabric-contract-api");
const vulnerability_records_1 = require("./vulnerability-records");
const abi = require("ethereumjs-abi");
const Cloudant = require("@cloudant/cloudant");
// const me = 'IBMid-5500091BVJ'; // Set this to your own account.
// const password = 'IBMCloud4!';
// Initialize the library with my account.
// const cloudant = Cloudant({ account: me, password: password});
// const cloudant = Cloudant({ url: 'https://f1ab26d4-7cce-4f62-bbe9-df56b09ed5bc-bluemix.cloudantnosqldb.appdomain.cloud', plugins: { iamauth: { iamApiKey: 'VL_2K5Md6KREIenEg-GW9IhvRGJmLXB8URqB86TtGkky' } } });
const cloudant = Cloudant({ url: 'https://d402b46a-a6dc-493a-aa24-955795f7a190-bluemix:b421adb6be6386bd98c22c1cc7a3158f229ee9bf34b1fbf84960b002ae0a3f7d@d402b46a-a6dc-493a-aa24-955795f7a190-bluemix.cloudantnosqldb.appdomain.cloud', plugins: { iamauth: { iamApiKey: 'WfB8MGZXD3jKgfl06mOuAvjs2J3iqjAv8esWyCsq6b-4' } } });
const myCollectionName = 'CollectionOne';
let VulnerabilityRecordsContract = class VulnerabilityRecordsContract extends fabric_contract_api_1.Contract {
    async vulnerabilityRecordsExists(ctx, vulnerabilityRecordsId) {
        const buffer = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityRecordsId);
        return (!!buffer && buffer.length > 0);
    }
    async createVulnerabilityRecords(ctx, vulnerabilityRecordsId) {
        const exists = await this.vulnerabilityRecordsExists(ctx, vulnerabilityRecordsId);
        if (exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityRecordsId} already exists`);
        }
        const privateAsset = new vulnerability_records_1.VulnerabilityRecords();
        const transientData = ctx.stub.getTransient();
        if (transientData.size === 0) {
            throw new Error('The keys were not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilityID')) {
            throw new Error('The vulnerabilityID key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityID = transientData.get('vulnerabilityID').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vendorID')) {
            throw new Error('The vendorID key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorID = transientData.get('vendorID').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vendorName')) {
            throw new Error('The vendorName key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorName = transientData.get('vendorName').toString('utf8');
        if (transientData.size === 0 || !transientData.has('productName')) {
            throw new Error('The productName key was not specified in transient data. Please try again.');
        }
        privateAsset.productName = transientData.get('productName').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vulnerabilityType')) {
            throw new Error('The vulnerabilityType key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityType = transientData.get('vulnerabilityType').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vulnerabilitySeverity')) {
            throw new Error('The vulnerabilitySeverity key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilitySeverity = transientData.get('vulnerabilitySeverity').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vulnerabilityPath')) {
            throw new Error('The vulnerabilityPath key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityPath = transientData.get('vulnerabilityPath').toString('utf8');
        if (transientData.size === 0 || !transientData.has('vulnerabilityDesc')) {
            throw new Error('The vulnerabilityDesc key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityDesc = transientData.get('vulnerabilityDesc').toString('utf8');
        if (transientData.size === 0 || !transientData.has('gracePeriod')) {
            throw new Error('The gracePeriod key was not specified in transient data. Please try again.');
        }
        privateAsset.gracePeriod = transientData.get('gracePeriod').toString('utf8');
        if (transientData.size === 0 || !transientData.has('approvedOn')) {
            throw new Error('The approvedOn key was not specified in transient data. Please try again.');
        }
        privateAsset.approvedOn = transientData.get('approvedOn').toString('utf8');
        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityRecordsId, Buffer.from(JSON.stringify(privateAsset)));
    }
    async readVulnerabilityRecords(ctx, vulnerabilityRecordsId) {
        const exists = await this.vulnerabilityRecordsExists(ctx, vulnerabilityRecordsId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityRecordsId} does not exist`);
        }
        let privateDataString;
        const privateData = await ctx.stub.getPrivateData(myCollectionName, vulnerabilityRecordsId);
        privateDataString = JSON.parse(privateData.toString());
        // console.log(privateDataString);
        return privateDataString;
    }
    async updateVulnerabilityRecords(ctx, vulnerabilityRecordsId) {
        const exists = await this.vulnerabilityRecordsExists(ctx, vulnerabilityRecordsId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityRecordsId} does not exist`);
        }
        const privateAsset = new vulnerability_records_1.VulnerabilityRecords();
        const transientData = ctx.stub.getTransient();
        if (transientData.size === 0) {
            throw new Error('The keys were not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilityID')) {
            throw new Error('The vulnerabilityID key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vendorID')) {
            throw new Error('The vendorID key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vendorName')) {
            throw new Error('The vendorName key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('productName')) {
            throw new Error('The productName key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilityType')) {
            throw new Error('The vulnerabilityType key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilitySeverity')) {
            throw new Error('The vulnerabilitySeverity key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilityPath')) {
            throw new Error('The vulnerabilityPath key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('vulnerabilityDesc')) {
            throw new Error('The vulnerabilityDesc key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('gracePeriod')) {
            throw new Error('The gracePeriod key was not specified in transient data. Please try again.');
        }
        if (transientData.size === 0 || !transientData.has('approvedOn')) {
            throw new Error('The approvedOn key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityID = transientData.get('vulnerabilityID').toString('utf8');
        privateAsset.vendorID = transientData.get('vendorID').toString('utf8');
        privateAsset.vendorName = transientData.get('vendorName').toString('utf8');
        privateAsset.productName = transientData.get('productName').toString('utf8');
        privateAsset.vulnerabilityType = transientData.get('vulnerabilityType').toString('utf8');
        privateAsset.vulnerabilitySeverity = transientData.get('vulnerabilitySeverity').toString('utf8');
        privateAsset.vulnerabilityPath = transientData.get('vulnerabilityPath').toString('utf8');
        privateAsset.vulnerabilityDesc = transientData.get('vulnerabilityDesc').toString('utf8');
        privateAsset.gracePeriod = transientData.get('gracePeriod').toString('utf8');
        privateAsset.approvedOn = transientData.get('approvedOn').toString('utf8');
        // console.log(privateAsset);
        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityRecordsId, Buffer.from(JSON.stringify(privateAsset)));
    }
    async deleteVulnerabilityRecords(ctx, vulnerabilityRecordsId) {
        const exists = await this.vulnerabilityRecordsExists(ctx, vulnerabilityRecordsId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityRecordsId} does not exist`);
        }
        await ctx.stub.deletePrivateData(myCollectionName, vulnerabilityRecordsId);
    }
    async verifyVulnerabilityRecords(ctx, vulnerabilityRecordsId, objectToVerify) {
        // Convert user provided object into a hash
        const hashToVerify = crypto.createHash('sha256').update(JSON.stringify(objectToVerify)).digest('hex');
        const pdHashBytes = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityRecordsId);
        if (pdHashBytes.length === 0) {
            throw new Error(`No private data hash with the Key: ${vulnerabilityRecordsId}`);
        }
        const actualHash = pdHashBytes.toString('hex');
        // Compare the hash calculated (from object provided) and the hash stored on public ledger
        if (hashToVerify === actualHash) {
            return true;
        }
        else {
            return false;
        }
    }
    // data-sender.ts
    interledgerAbort(ctx) {
        return null;
    }
    interledgerCommit(ctx) {
        return null;
    }
    /* @Transaction()
    public async asyncCall() {
        await cloudant.db.create('VulnerabilityRecords');
    }*/
    async emitData(ctx, vulnerabilityID, data) {
        const iles = {
            Id: vulnerabilityID,
            Data: data
        };
        await ctx.stub.putState('id', Buffer.from(vulnerabilityID));
        const vulnerabilityIDPass = Number(vulnerabilityID);
        // const passDataString = vulnerabilityID + data;
        // const passData = Buffer.from(passDataString).toString('base64');
        const abiPass = '0x' + abi.rawEncode(['int', 'string'], [vulnerabilityIDPass, data]).toString('hex');
        console.log('Data transferred to Public Ledger via Interledger Component:\n');
        console.log(abiPass);
        ctx.stub.setEvent('InterledgerEventSending', Buffer.from(abiPass));
        return null;
    }
    // data-receiver.ts
    async interledgerReceive(ctx, nonceString, secretIDDataBytes) {
        console.log('Data received from Public Ledger via Interledger Component\n');
        console.log(secretIDDataBytes);
        const middle = Math.ceil(secretIDDataBytes.length / 2);
        const secretIDString = secretIDDataBytes.slice(0, middle + 1);
        // console.log(secretIDString);
        const vulIdString = secretIDDataBytes.slice(middle + 1);
        // console.log(vulIdString);
        const secretID = parseInt(secretIDString, 16).toString(10);
        const vulnerabilityID = parseInt(vulIdString, 16).toString(10);
        // console.log(`vulnerability id: ${vulnerabilityID}`);
        const nonce = nonceString;
        const res = this.vulnerabilityRecordsExists(ctx, secretID); // JSON Obj
        if (!res) {
            ctx.stub.setEvent('InterledgerEventRejected', Buffer.from(JSON.stringify(nonce)));
            throw new Error(`The asset vulnerability ${secretID} does not exist`);
        }
        const result = await this.readVulnerabilityRecords(ctx, secretID);
        console.log('Full Vulnerability Information for Secret:\n');
        console.log(result);
        // await cloudant.db.create(secretID);
        cloudant.use('database-vulnerability').insert(result, vulnerabilityID);
        console.log('Data Inserted Successfully');
        const dataItem = {
            Nonce: nonce,
            Data: secretID
        };
        await ctx.stub.putState('items', Buffer.from(JSON.stringify(dataItem)));
        ctx.stub.setEvent('InterledgerEventAccepted', Buffer.from(JSON.stringify(nonce)));
        const urlString = 'https://d402b46a-a6dc-493a-aa24-955795f7a190-bluemix.cloudantnosqldb.appdomain.cloud/database-vulnerability/_design/show_example/_show/Beu/' + vulnerabilityID;
        console.log(urlString);
        this.emitData(ctx, vulnerabilityID, urlString);
        return result;
    }
};
__decorate([
    fabric_contract_api_1.Transaction(false),
    fabric_contract_api_1.Returns('boolean'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityRecordsContract.prototype, "vulnerabilityRecordsExists", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityRecordsContract.prototype, "createVulnerabilityRecords", null);
__decorate([
    fabric_contract_api_1.Transaction(false),
    fabric_contract_api_1.Returns('VulnerabilityRecords'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityRecordsContract.prototype, "readVulnerabilityRecords", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityRecordsContract.prototype, "updateVulnerabilityRecords", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityRecordsContract.prototype, "deleteVulnerabilityRecords", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String, vulnerability_records_1.VulnerabilityRecords]),
    __metadata("design:returntype", Promise)
], VulnerabilityRecordsContract.prototype, "verifyVulnerabilityRecords", null);
__decorate([
    fabric_contract_api_1.Transaction(false),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context]),
    __metadata("design:returntype", Error)
], VulnerabilityRecordsContract.prototype, "interledgerAbort", null);
__decorate([
    fabric_contract_api_1.Transaction(false),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context]),
    __metadata("design:returntype", Error)
], VulnerabilityRecordsContract.prototype, "interledgerCommit", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityRecordsContract.prototype, "emitData", null);
__decorate([
    fabric_contract_api_1.Transaction(),
    fabric_contract_api_1.Returns('Vulnerability'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [fabric_contract_api_1.Context, String, String]),
    __metadata("design:returntype", Promise)
], VulnerabilityRecordsContract.prototype, "interledgerReceive", null);
VulnerabilityRecordsContract = __decorate([
    fabric_contract_api_1.Info({ title: 'VulnerabilityRecordsContract', description: 'My Private Data Smart Contract' })
], VulnerabilityRecordsContract);
exports.VulnerabilityRecordsContract = VulnerabilityRecordsContract;
//# sourceMappingURL=vulnerability-records-contract.js.map