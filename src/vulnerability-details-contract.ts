/*
 * SPDX-License-Identifier: Apache-2.0
 */

import crypto = require('crypto');
import { Context, Contract, Info, Returns, Transaction } from 'fabric-contract-api';
import { VulnerabilityDetails } from './vulnerability-details';
const myCollectionName: string = 'CollectionOne';

@Info({title: 'VulnerabilityDetailsContract', description: 'ARD Private Vulnerability Details Smart Contract' })
export class VulnerabilityDetailsContract extends Contract {

    @Transaction(false)
    @Returns('boolean')
    public async vulnerabilityDetailsExists(ctx: Context, vulnerabilityDetailsId: string): Promise<boolean> {
        const buffer: Buffer = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityDetailsId);
        return (!!buffer && buffer.length > 0);
    }

    @Transaction()
    public async createVulnerabilityDetails(ctx: Context, vulnerabilityDetailsId: string): Promise<void> {
        const exists: boolean = await this.vulnerabilityDetailsExists(ctx, vulnerabilityDetailsId);
        if (exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityDetailsId} already exists`);
        }

        const privateAsset: VulnerabilityDetails = new VulnerabilityDetails();

        const transientData: Map<string, Buffer> = ctx.stub.getTransient();
        if (transientData.size === 0 || !transientData.has('vendorID')) {
            throw new Error('The vendorID key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorID = transientData.get('vendorID').toString('utf8');

        if (transientData.size === 0 || !transientData.has('vendorName')) {
            throw new Error('The vendorName key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorName = transientData.get('vendorName').toString('utf8');

        if (transientData.size === 0 || !transientData.has('productName')) {
            throw new Error('The productName key was not specified in transient data. Please try again.');
        }
        privateAsset.productName = transientData.get('productName').toString('utf8');

        if (transientData.size === 0 || !transientData.has('vulnerabilityType')) {
            throw new Error('The vulnerabilityType key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityType = transientData.get('vulnerabilityType').toString('utf8');

        if (transientData.size === 0 || !transientData.has('vulnerabilitySeverity')) {
            throw new Error('The vulnerabilitySeverity key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilitySeverity = transientData.get('vulnerabilitySeverity').toString('utf8');

        if (transientData.size === 0 || !transientData.has('patchState')) {
            throw new Error('The patchState key was not specified in transient data. Please try again.');
        }
        privateAsset.patchState = transientData.get('patchState').toString('utf8');

        if (transientData.size === 0 || !transientData.has('gracePeriod')) {
            throw new Error('The gracePeriod key was not specified in transient data. Please try again.');
        }
        privateAsset.gracePeriod = transientData.get('gracePeriod').toString('utf8');

        if (transientData.size === 0 || !transientData.has('bountyAmount')) {
            throw new Error('The bountyAmount key was not specified in transient data. Please try again.');
        }
        privateAsset.bountyAmount = transientData.get('bountyAmount').toString('utf8');


        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityDetailsId, Buffer.from(JSON.stringify(privateAsset)));
    }

    @Transaction(false)
    @Returns('VulnerabilityDetails')
    public async readVulnerabilityDetails(ctx: Context, vulnerabilityDetailsId: string): Promise<string> {
        const exists: boolean = await this.vulnerabilityDetailsExists(ctx, vulnerabilityDetailsId);
        if (!exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityDetailsId} does not exist`);
        }

        let privateDataString: string;
        const privateData: Buffer = await ctx.stub.getPrivateData(myCollectionName, vulnerabilityDetailsId);

        privateDataString = JSON.parse(privateData.toString());
        return privateDataString;
    }

    @Transaction()
    public async updateVulnerabilityDetails(ctx: Context, vulnerabilityDetailsId: string): Promise<void> {
        const exists: boolean = await this.vulnerabilityDetailsExists(ctx, vulnerabilityDetailsId);
        if (!exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityDetailsId} does not exist`);
        }

        const privateAsset: VulnerabilityDetails = new VulnerabilityDetails();

        const transientData: Map<string, Buffer> = ctx.stub.getTransient();
        if (transientData.size === 0 || !transientData.has('patchState')) {
            throw new Error('The patchState key was not specified in transient data. Please try again.');
        }
        privateAsset.patchState = transientData.get('patchState').toString('utf8');

        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityDetailsId, Buffer.from(JSON.stringify(privateAsset)));
    }

    @Transaction()
    public async deleteVulnerabilityDetails(ctx: Context, vulnerabilityDetailsId: string): Promise<void> {
        const exists: boolean = await this.vulnerabilityDetailsExists(ctx, vulnerabilityDetailsId);
        if (!exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityDetailsId} does not exist`);
        }
        await ctx.stub.deletePrivateData(myCollectionName, vulnerabilityDetailsId);
    }

    @Transaction()
    public async verifyVulnerabilityDetails(ctx: Context, vulnerabilityDetailsId: string, objectToVerify: VulnerabilityDetails): Promise<boolean> {
        // Convert user provided object into a hash
        const hashToVerify: string = crypto.createHash('sha256').update(JSON.stringify(objectToVerify)).digest('hex');
        const pdHashBytes: Buffer = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityDetailsId);
        if (pdHashBytes.length === 0) {
            throw new Error(`No private data hash with the Key: ${vulnerabilityDetailsId}`);
        }

        const actualHash: string = pdHashBytes.toString('hex');

        // Compare the hash calculated (from object provided) and the hash stored on public ledger
        if (hashToVerify === actualHash) {
            return true;
        } else {
            return false;
        }
    }

}
