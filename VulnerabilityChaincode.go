
package main

import (
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)


// Peers in authoritymsp and vendormsp will have this private data in a side database
type vulnerability struct {
	  ObjectType string 'json:"docType"'
	  SecretData string 'json:"secretData"'
	  VendorId string 'json:"vendorId"'
	  VulnerabilityId string 'json: "vulnerabilityId"'
	  VendorName string 'json:"vendorName"'
	  ProductName string 'json:"productName"'
	  VulnerabilityType string 'json:"vulnerabilityType"'
	  VulnerabilitySeverity string 'json:"vulnerabilitySeverity"'
	  PatchState string 'json:"patchState"'
	  PaymentState string 'json:"paymentState"'
	  GracePeriod string 'json:"gracePeriod"'
	  BountyAmt string 'json:"bountyAmt"'
	  
}

// Only peers in authoritymsp will have this private data in a side database
type vulnerabilityPrivateDetails struct {
	ObjectType string 'json:"docType"'
	VulnerabilityId string 'json:"vulnerabilityId"'
	ExpertContact string 'json:"expertContact"'
  
}

type VulnerabilityChaincode struct { // defined to implement CC interface
}



// Implement Barebone Init
func (t *VulnerabilityChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {

	fmt.Println("Successfully init chaincode")

	return shim.Success(nil)

}

// Implement Invoke
func (t *VulnerabilityChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {


	// Get function name and args
	function, args := stub.GetFunctionAndParameters()
	fmt.Println("Start Invoke" + function)

	switch function {

	case "initVulnerability"://create new vulnerability
		return t.initVulnerability(stub, args)
	case "readVulnerability":// read vulnerability
		return t.readVulnerability(stub, args)
	case "readExpertContact"://read private details
		return t.readExpertContact(stub, args)
	//case "queryVulnerabilityByVendorId":// query by vendor - parameterized rich query
	//	return t.queryVulnerabilityByVendorId(stub, args)
	
	default:
		//error
		fmt.Println("invoke did not find func: "+ function)
		return shim.Error("Invalid invoke function name.")
	}

}

func (t *VulnerabilityChaincode) initVulnerability(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var err error

	type vulnerabilityTransientInput struct {
		SecretData string 'json:"secretData"'
		VendorId string 'json:"vendorId"'
		VulnerabilityId string 'json: "vulnerabilityId"'
		VendorName string 'json:"vendorName"'
		ProductName string 'json:"productName"'
		VulnerabilityType string 'json:"vulnerabilityType"'
		VulnerabilitySeverity string 'json:"vulnerabilitySeverity"'
		PatchState string 'json:"patchState"'
		PaymentState string 'json:"paymentState"'
		GracePeriod string 'json:"gracePeriod"'
		BountyAmt string 'json:"bountyAmt"'
		ExpertContact string 'json:"expertContact"'

	}

	// ==== Input sanitation ====
	fmt.Println("- start init vulnerability")

	if len(args) != 0 {
		return shim.Error("Incorrect number of arguments. Private data must be passed in transient map.")
	}

	transMap, err := stub.GetTransient()
	if err != nil {
		return shim.Error("Error getting transient: " + err.Error())
	}

	if _, ok := transMap["vulnerability"]; !ok {
		return shim.Error("vulnerability must be a key in the transient map")
	}

	if len(transMap["vulnerability"]) == 0 {
		return shim.Error("vulnerability value in the transient map must be a non-empty JSON string")
	}

	var vulnerabilityInput vulnerabilityTransientInput
	err = json.Unmarshal(transMap["vulnerability"], &vulnerabilityInput)
	if err != nil {
		return shim.Error("Failed to decode JSON of: " + string(transMap["vulnerability"]))
	}

	if len(vulnerabilityInput.SecretData) == 0 {
		return shim.Error("Secret Data field must be a non-empty string")
	}
	if len(vulnerabilityInput.VendorId) == 0 {
		return shim.Error("Vendor ID field must be a non-empty string")
	}
	if len(vulnerabilityInput.VulnerabilityId) == 0 {
		return shim.Error("Vulnerability Id field must be a non-empty string")
	}
	if len(vulnerabilityInput.VendorName) == 0 {
		return shim.Error("Vendor Name field must be a non-empty string")
	}
	if len(vulnerabilityInput.ProductName) == 0 {
		return shim.Error("Product Name field must be a non-empty string")
	}
	if len(vulnerabilityInput.VulnerabilityType) == 0 {
		return shim.Error("Vulnerability Type field must be a non-empty string")
	}
	if len(vulnerabilityInput.VulnerabilitySeverity) == 0 {
		return shim.Error("Vulnerability Severity field must be a non-empty string")
	}
	if len(vulnerabilityInput.PatchState) == 0 {
		return shim.Error("Patch State field must be a non-empty string")
	}
	if len(vulnerabilityInput.PaymentState) == 0 {
		return shim.Error("Payment State field must be a non-empty string")
	}
	if len(vulnerabilityInput.GracePeriod) == 0 {
		return shim.Error("Grace Period field must be a non-empty string")
	}
	if len(vulnerabilityInput.BountyAmt) == 0 {
		return shim.Error("Bounty Amount field must be a non-empty string")
	}
	if len(vulnerabilityInput.ExpertContact) == 0 {
		return shim.Error("Expert Contact field must be a non-empty string")
	}
	

	// ==== Check if vulnerability already exists ====
	vulnerabilityAsBytes, err := stub.GetPrivateData("collectionVulnerability", vulnerabilityInput.SecretData)
	if err != nil {
		return shim.Error("Failed to get vulnerability: " + err.Error())
	} else if vulnerabilityAsBytes != nil {
		fmt.Println("This vulnerability already exists: " + vulnerabilityInput.SecretData)
		return shim.Error("This vulnerability already exists: " + vulnerabilityInput.SecretData)
	}

	// ==== Create vulnerability object, marshal to JSON, and save to state ====
	vulnerability := &vulnerability{
		ObjectType: "vulnerability",
		SecretData:      vulnerabilityInput.SecretData,
		VendorId:       vulnerabilityInput.VendorId,
		VulnerabilityId:      vulnerabilityInput.VulnerabilityId,
		VendorName:       vulnerabilityInput.VendorName,
		ProductName:       vulnerabilityInput.ProductName,
		VulnerabilityType:       vulnerabilityInput.VulnerabilityType,
		VulnerabilitySeverity:       vulnerabilityInput.VulnerabilitySeverity,
		PatchState:       vulnerabilityInput.PatchState,
		PaymentState:       vulnerabilityInput.PaymentState,
		GracePeriod:       vulnerabilityInput.GracePeriod,
		BountyAmt:       vulnerabilityInput.BountyAmt,
	}
	vulnerabilityJSONasBytes, err := json.Marshal(vulnerability)
	if err != nil {
		return shim.Error(err.Error())
	}

	// === Save vulnerability to state ===
	err = stub.PutPrivateData("collectionVulnerability", vulnerabilityInput.SecretData, vulnerabilityJSONasBytes)
	if err != nil {
		return shim.Error(err.Error())
	}

	// ==== Create vulnerability private details object with expert contact, marshal to JSON, and save to state ====
	vulnerabilityPrivateDetails := &vulnerabilityPrivateDetails{
		ObjectType: "vulnerabilityPrivateDetails",
		VulnerabilityId:       vulnerabilityInput.VulnerabilityId,
		ExpertContact:      vulnerabilityInput.ExpertContact,
	}
	vulnerabilityPrivateDetailsBytes, err := json.Marshal(vulnerabilityPrivateDetails)
	if err != nil {
		return shim.Error(err.Error())
	}
	err = stub.PutPrivateData("collectionVulnerabilityPrivateDetails", vulnerabilityInput.VulnerabilityId, vulnerabilityPrivateDetailsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}

	// Could index vulnerability to enable vulnerability-type based range queries -- queryByRange not included in this version of chaincode
	//  An 'index' is a normal key/value entry in state.
	//  The key is a composite key, with the elements that you want to range query on listed first.
	//  In our case, the composite key is based on indexName~vulnerability~name.
	//  This will enable very efficient state range queries based on composite keys matching indexName~vulnerabilityType~*
	indexName := "vulnerability~name"
	vulnerabilityNameIndexKey, err := stub.CreateCompositeKey(indexName, []string{vulnerability.VulnerabilityType, vulnerability.SecretData})
	if err != nil {
		return shim.Error(err.Error())
	}
	//  Save index entry to state. Only the key name is needed, no need to store a duplicate copy of the vulnerability.
	//  Note - passing a 'nil' value will effectively delete the key from state, therefore we pass null character as value
	value := []byte{0x00}
	stub.PutPrivateData("collectionVulnerability", vulnerabilityNameIndexKey, value)

	// ==== Vulnerability saved and indexed. Return success ====
	fmt.Println("- end init vulnerability")
	return shim.Success(nil)

}

func (t *VulnerabilityChaincode) readVulnerability(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var secretData, jsonResp string
	var err error

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting Secret to query")
	}

	secretData = args[0]
	valAsbytes, err := stub.GetPrivateData("collectionVulnerability", secretData) //get the vendor history from chaincode state
	if err != nil {
		jsonResp = "{\"Error\":\"Failed to get state for " + secretData + "\"}"
		return shim.Error(jsonResp)
	} else if valAsbytes == nil {
		jsonResp = "{\"Error\":\"Vulnerability details do not exist: " + secretData + "\"}"
		return shim.Error(jsonResp)
	}

	return shim.Success(string(valAsbytes))


}

func (t *VulnerabilityChaincode) readExpertContact(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var vulnerabilityId, jsonResp string
	var err error

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting ID of vulnerability to query")
	}

	vulnerabilityId = args[0]
	valAsbytes, err := stub.GetPrivateData("collectionVulnerabilityPrivateDetails", vulnerabilityId) //get the expert private details from chaincode state
	if err != nil {
		jsonResp = "{\"Error\":\"Failed to get private details for " + vulnerabilityId + ": " + err.Error() + "\"}"
		return shim.Error(jsonResp)
	} else if valAsbytes == nil {
		jsonResp = "{\"Error\":\"Vulnerability private details do not exist: " + vulnerabilityId + "\"}"
		return shim.Error(jsonResp)
	}

	return shim.Success(string(valAsbytes))


}

func main() {

	err := shim.Start(new(VulnerabilityChaincode))

	if err != nil {
		fmt.Printf("Error starting the Vulnerability Contract: %s", err)
	}

}



// ===== Parameterized rich query =================================================
// queryVulnerabilityByVendorId queries for vulnerability based on a passed in VendorId.
// This is an example of a parameterized query where the query logic is baked into the chaincode,
// and accepting a single query parameter (vendorId).
// Only available on state databases that support rich query (e.g. CouchDB)
// =========================================================================================
//func (t *VulnerabilityChaincode) queryVulnerabilityByVendorId(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	//   0
	// "Piixyz"
//	if len(args) < 1 {
//		return shim.Error("Incorrect number of arguments. Expecting 1 - vendor ID")
//	}

//	vendorId := strings.ToLower(args[0])

//	queryString := fmt.Sprintf("{\"selector\":{\"docType\":\"vulnerability\",\"vendorId\":\"%s\"}}", vendorId)

//	queryResults, err := getQueryResultForQueryString(stub, queryString)
//	if err != nil {
//		return shim.Error(err.Error())
//	}
//	return shim.Success(queryResults)
//}

// ===== Ad-hoc rich query not included, as discussed =================================================























