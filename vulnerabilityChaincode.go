
package main

import (
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric-chaincode-go/shim"
	pb "github.com/hyperledger/fabric-protos-go/peer"
)



// Peers in Org1 and Org2 will have this private data in a side database
type vulnerabilityCollection struct {
	  //ObjectType string 'json:"docType"''
	  Id string 'json:"id"'
	  VendorName string 'json:"vendorName"'
	  ProductName string 'json:"productName"'
	  VulType string 'json:"vulType"'
	  VulSeverity string 'json:"vulSeverity"'
	  PatchState string 'json:"patchState"'
	  PaymentState string 'json:"paymentState"'
	  GracePeriod float64 'json:"gracePeriod"'
	  BountyAmt float64 'json:"bountyAmt"'
	  
}

// Only peers in Org1 will have this private data in a side database
type vulnerabilityPrivateDetails struct {
	//ObjectType string 'json:"docType"''
	Id string 'json:"Id"'
	VendorName string 'json:"vendorName"'
	ProductName string 'json:"productName"'
	ResearcherContact string 'json:"researcherContact"'
  
}

type VulChaincode struct { // defined to implement CC interface
}

func main() {

	err := shim.Start(new(VulChaincode))

	if err != nil {
		fmt.Printf("Error starting the Vulnerability Contract: %s", err)
	}

}

// Implement Barebone Init
func (t *VulChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {

	fmt.Println("Successfully init chaincode")

	return shim.Success(nil)

}

// Implement Invoke
func (t *VulChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {

	fmt.Println("Start Invoke")
	defer fmt.Println("Stop Invoke")

	// Get function name and args
	function, args := stub.GetFunctionAndParameters()

	switch function {

	case "createVul":
		return t.createVul(stub, args)
	case "getVul":
		return t.getVul(stub, args)
	case "getPaymentDetails":
		return t.getResearcherContact(stub, args)
	default:
		return shim.Error("Invalid invoke function name.")
	}

}

func (t *VulChaincode) createVul(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	id := args[0]																							
	vendorName := args[1]
	productName := args[2]
	vulType := args[3]
	vulSeverity := args[4]
	patchState := args[5]
	paymentState := args[6]
	gracePeriod, err1 := strconv.ParseFloat(args[7], 32)
	bountyAmt, err2 := strconv.ParseFloat(args[8], 32)
	researcherContact := args[9]

	if err1 != nil || err2 != nil {
		return shim.Error("Error parsing the values")
	}

	vulnerabilityCollection := &vulnerabilityCollection{id, vendorName, productName, vulType, vulSeverity, patchState, paymentState, gracePeriod, bountyAmt}
	vulnerabilityCollectionBytes, err3 := json.Marshal(vulnerabilityCollection)

	if err3 != nil {
		return shim.Error(err1.Error())
	}

	vulnerabilityPrivateDetails := &vulnerabilityPrivateDetails{id, vendorName, productName, researcherContact}
	vulnerabilityPrivateDetailsBytes, err4 := json.Marshal(vulnerabilityPrivateDetailsPrice)

	if err4 != nil {
		return shim.Error(err2.Error())
	}

	err5 := stub.PutPrivateData("vulnerabilityCollection", id, vulnerabilityCollectionBytes)

	if err5 != nil {
		return shim.Error(err5.Error())
	}

	err6 := stub.PutPrivateData("vulnerabilityPrivateDetails", id, vulnerabilityPrivateDetailsBytes)

	if err6 != nil {
		return shim.Error(err6.Error())
	}

	jsonVulnerabilityCollection, err7 := json.Marshal(vulnerabilityCollection)
	if err7 != nil {
		return shim.Error(err7.Error())
	}

	return shim.Success(jsonVulnerabilityCollection)

}

func (t *VulChaincode) getVul(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	id := args[0]
	vulnerabilityCollection := vulnerabilityCollection{}

	vulnerabilityCollectionBytes, err1 := stub.GetPrivateData("vulnerabilityCollection", id)
	if err1 != nil {
		return shim.Error(err1.Error())
	}

	err2 := json.Unmarshal(vulnerabilityCollectionBytes, &pvulnerabilityCollection)

	if err2 != nil {
		fmt.Println("Error unmarshalling object with id: " + id)
		return shim.Error(err2.Error())
	}

	jsonVulnerabilityCollection, err3 := json.Marshal(vulnerabilityCollection)
	if err3 != nil {
		return shim.Error(err3.Error())
	}

	return shim.Success(jsonVulnerabilityCollection)

}

func (t *VulChaincode) getResearcherContact(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	id := args[0]
	vulnerabilityPrivateDetails := vulnerabilityPrivateDetails{}

	vulnerabilityPrivateDetailsBytes, err1 := stub.GetPrivateData("vulnerabilityPrivateDetails", id)
	if err1 != nil {
		return shim.Error(err1.Error())
	}

	err2 := json.Unmarshal(vulnerabilityPrivateDetailsBytes, &vulnerabilityPrivateDetails)

	if err2 != nil {
		fmt.Println("Error unmarshalling object with id: " + id)
		return shim.Error(err2.Error())
	}

	jsonVulnerabilityPrivateDetails, err3 := json.Marshal(vulnerabilityPrivateDetails)
	if err3 != nil {
		return shim.Error(err3.Error())
	}

	return shim.Success(jsonVulnerabilityPrivateDetails)

}




















