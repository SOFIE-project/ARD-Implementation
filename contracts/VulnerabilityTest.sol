pragma solidity ^0.6.0;

import "./Vulnerability.sol";

// Provides testing functions
contract VulnerabilityRegistryTest is VulnerabilityRegistry {

    // timestamp, vendorName, productName and productVersion are not important for testing
    // otherwise stack too deep execption
    // if more parameters are needed => split this into separate functions
    function setContract(bytes32 contractId, address payable researcher,
                        address vendor, RewardState rewardState,
                        uint rewardAmount, Status status,
                        bytes32 hashlock, uint timelock,
                        uint secret, string memory vulnerabilityLocation,
                        bytes32 _vulnerabilityHash) public payable {

        Reward memory reward = Reward({state: rewardState, amount: rewardAmount});
        Metadata memory metadata = Metadata({
                                        vendor: vendor,
                                        vendorName: 0x0,
                                        productName: 0x0,
                                        productVersion: 0x0,
                                        vulnerabilityHash: _vulnerabilityHash
                                    });

        Contracts[contractId] = VulnerabilityContract({
                                      researcher: researcher,
                                        metadata: metadata,
                                        timestamp: now,
                                      reward: reward,
                                      status: status,
                                      hashlock: hashlock,
                                      timelock: timelock,
                                      secret: secret,
                                      vulnerabilityLocation: vulnerabilityLocation});
    }

    function hashlockCheck(uint secret, bytes32 hashlock) public pure returns(bytes32 hashlockComputed, bool equal) {
        
        hashlockComputed = keccak256(abi.encodePacked(secret));
        equal = (hashlock == hashlockComputed);
    }

    function produceContractId(address _vendor, bytes32 _hashlock, bytes32 _vulnerabilityHash) public view returns (bytes32) {

        return keccak256(
            abi.encodePacked(
                msg.sender,
                _vendor,
                _hashlock,
                _vulnerabilityHash
            )
        );

    }

}