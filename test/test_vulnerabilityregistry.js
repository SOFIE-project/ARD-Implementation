const truffleAssert = require('truffle-assertions');
const Registry = artifacts.require("VulnerabilityRegistry");
const RegistryTest = artifacts.require("VulnerabilityRegistryTest");

contract("VulnerabilityRegistry", function(accounts) {

    const researcher = accounts[0];
    const vendor = accounts[1];
    const authority = accounts[2];
    
    const STATUS = {
        Pending: 0,
        Invalid: 1,
        Valid: 2,
        Acknowledged: 3,
        Patched: 4,
        Disclosed: 5
    }

    const REWARDSTATE = {
        NULL: 0,
        SET: 1,
        TOCLAIM: 2,
        TOREFUND: 3,
        SENT: 4
    }

    describe("Testing secret - hashlock computation", function() {

        let vulnerabilityRegistry;

        beforeEach(async function() {

            vulnerabilityRegistry = await RegistryTest.new({from: authority});
        });

        it("Should correctly create a secret-hashlock pair", async function() {

            let secret = 123;
            let hashlock = web3.utils.soliditySha3({type: 'uint', value: secret});

            let result = await vulnerabilityRegistry.hashlockCheck(secret, hashlock);

            assert.equal(result.hashlockComputed, hashlock, "Hashlock: Hashlock does not match with the computed one");
            assert.equal(result.equal, true, "Boolean: Hashlock does not match with the computed one");
        });
    });


    describe("Testing newVulnerability()", function() {

        let vulnerabilityRegistry;
        let secret = 123;
        let hashlock = web3.utils.soliditySha3({type: 'uint', value: secret});

        beforeEach(async function() {

            vulnerabilityRegistry = await RegistryTest.new({from: authority});
        });

        it("Should correctly create a a new vulnerability contract", async function() {

            let metadata = web3.utils.fromAscii(new String(13245678910)); // Random metadata in bytes32
            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, metadata, {from: researcher});

            // Test event fired
            truffleAssert.eventEmitted(tx, 'LogVulnerabilityNew', (ev) => {                
                return (
                        ev.researcher === researcher &&
                        ev.vendor === vendor &&
                        ev.hashlock === hashlock 
                        // TODO test metadata (problems with padded zeros from Solidity event)
                        );
            }, 'LogVulnerabilityNew event did not fire with correct parameters');

            // Get contractId from event
            let contractId = tx.receipt.logs[0].args.contractId;
            let contractData = await vulnerabilityRegistry.getContractById(contractId);
                // Check a new contract entry is correct
            assert.equal(contractData.researcher, researcher, "Researcher does not match");
            assert.equal(contractData.vendor, vendor, "Vendor does not match");
            assert.equal(contractData.rewardState, REWARDSTATE.NULL, "Reward state should be NULL (0)");
            assert.equal(contractData.rewardAmount, 0, "Reward amount should be 0");
            assert.equal(contractData.status, STATUS.Pending, "Contract status should be Pending (0)");
            assert.equal(contractData.hashlock, hashlock, "Hashlock does not match");
            assert.equal(contractData.timelock, 0, "Timelock should be 0");
            assert.equal(contractData.secret, 0, "Secret should be 0");
            assert.equal(contractData.vulnerabilityLocation, "", "VulnerabilityLocation should be empty string");            
        });

        it("Should NOT allow the creation of two contracts with the same id", async function() {

            let metadata = web3.utils.fromAscii(new String(13245678910)); // Random metadata in bytes32
            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, metadata, {from: researcher});
            
            await truffleAssert.fails(
                vulnerabilityRegistry.newVulnerability(vendor, hashlock, metadata, {from: researcher}),
                truffleAssert.ErrorType.REVERT,
                "Contract already exists" // String of the revert
            );
        });

        it("Should NOT allow the creation of two contracts with the same metadata", async function() {

            let metadata = web3.utils.fromAscii(new String(13245678910)); // Random metadata in bytes32
            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, metadata, {from: researcher});
            
            await truffleAssert.fails(
                vulnerabilityRegistry.newVulnerability(vendor, hashlock, metadata, {from: authority}), // change at least one input to avoid sameId error case 
                truffleAssert.ErrorType.REVERT,
                "Meta already exists" // String of the revert
            );
        });
    });


    describe("Testing approve()", function() {

        let contractId;
        let vulnerabilityRegistry;

        beforeEach(async function() {

            let secret = 123;
            let hashlock = web3.utils.soliditySha3({type: 'uint', value: secret});

            vulnerabilityRegistry = await RegistryTest.new({from: authority});
            
            let metadata = web3.utils.fromAscii(new String(13245678910)); // Random metadata in bytes32
            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, metadata, {from: researcher});

            contractId = tx.receipt.logs[0].args.contractId;
        });

        it("Should NOT approve a stored vulnerability: authority deciion", async function() {

            let date = new Date();
            let timelock = date.getTime() + 100000; // 100K milliseconds in the future
            let tx = await vulnerabilityRegistry.approve(timelock, contractId, false, {from: authority});
    
            // Test event fired
            truffleAssert.eventEmitted(tx, 'LogVulnerabilityApproval', (ev) => {                
                return (
                        ev.timelock.toNumber() === timelock  &&
                        ev.status.toNumber() === STATUS.Invalid
                        );
            }, 'LogVulnerabilityApproval event did not fire with correct parameters');
        });

        it("Should approve a stored vulnerability", async function() {

            let date = new Date();
            let timelock = date.getTime() + 100000; // 100K milliseconds in the future
            let tx = await vulnerabilityRegistry.approve(timelock, contractId, true, {from: authority});
    
            // Test event fired
            truffleAssert.eventEmitted(tx, 'LogVulnerabilityApproval', (ev) => {                
                return (
                        ev.timelock.toNumber() === timelock  &&
                        ev.status.toNumber() === STATUS.Valid
                        );
            }, 'LogVulnerabilityApproval event did not fire with correct parameters');

            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status, STATUS.Valid, "Contract status should be Valid ("+STATUS.Valid+")");
            assert.equal(contractData.timelock, timelock, "Timelock should be " + timelock);
        });


        // The check of the authority calling is done by openzeppelin ownable -> no need to test
    });


    describe("Testing acknowledge()", function() {

        let contractId;
        let vulnerabilityRegistry;

        beforeEach(async function() {

            let secret = 123;
            let hashlock = web3.utils.soliditySha3({type: 'uint', value: secret});
            let date = new Date();
            let timelock = date.getTime() + 100000; // 100K milliseconds in the future
            let metadata = web3.utils.fromAscii(new String(13245678910)); // Random metadata in bytes32
 
            vulnerabilityRegistry = await RegistryTest.new({from: authority});           
            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, metadata, {from: researcher});
            contractId = tx.receipt.logs[0].args.contractId;

            await vulnerabilityRegistry.approve(timelock, contractId, true, {from: authority});
        });

        it("Should acknowledge an approved vulnerability", async function() {

            let bounty = web3.utils.toWei('1', 'ether');
            let tx = await vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: bounty});
    
            // Test event fired
            truffleAssert.eventEmitted(tx, 'LogVulnerabilityAcknowledgment', (ev) => {                
                return (
                        ev.vendor === vendor  &&
                        ev.bounty.toString() === bounty.toString() // too big to use .toNumber()
                        );
            }, 'LogVulnerabilityAcknowledgment event did not fire with correct parameters');

            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status, STATUS.Acknowledged, "Contract status should be Ackowledged ("+STATUS.Acknowledged+")");
            assert.equal(contractData.rewardState, REWARDSTATE.SET, "Reward state should be SET ("+REWARDSTATE.SET+")");
            assert.equal(contractData.rewardAmount, bounty, "Reward amount should be " + bounty.toString());
        });

        it("Should NOT acknowledge an approved vulnerability: input bounty does not match the sent value", async function() {

            let bounty = web3.utils.toWei('1', 'ether');
   
            await truffleAssert.fails(
                vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: 12}),
                "Value sent does not match the input bounty" // String of the revert
            );
        });

        it("Should NOT acknowledge an approved vulnerability: sender is not the vendor", async function() {

            let bounty = web3.utils.toWei('1', 'ether');
   
            await truffleAssert.fails(
                vulnerabilityRegistry.acknowledge(contractId, bounty, {from: researcher, value: bounty}),
                "Sender is not the Vendor" // String of the revert
            );
        });

        it("Should NOT acknowledge an approved vulnerability: contract is not in a Valid state", async function() {

            let bounty = web3.utils.toWei('1', 'ether');
            await vulnerabilityRegistry.setContract(contractId, researcher, vendor, REWARDSTATE.NULL, 0,
                                                    STATUS.Invalid, // <- status, Input breaking the condition (to check)
                                                    web3.utils.fromAscii("a"), 0, 0, "");

            await truffleAssert.fails(
                vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: bounty}),
                "Status is not Valid" // String of the revert
            );
        });

        it("Should NOT acknowledge an approved vulnerability: grace period elapsed", async function() {

            let bounty = web3.utils.toWei('1', 'ether');
            await vulnerabilityRegistry.setContract(contractId, researcher, vendor, REWARDSTATE.NULL, 0, 
                                                    STATUS.Valid, web3.utils.fromAscii("a"), 
                                                    0, // <- timelock, Input breaking the condition (to check)
                                                    0, "");

            await truffleAssert.fails(
                vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: bounty}),
                "The timelock has expired" // String of the revert
            );
        });

    });

    // TODO the patch function may miss a parameter, the patch itself
    describe("Testing patch()", function() {

        let contractId;
        let vulnerabilityRegistry;

        beforeEach(async function() {

            let secret = 123;
            let hashlock = web3.utils.soliditySha3({type: 'uint', value: secret});
            let date = new Date();
            let timelock = date.getTime() + 100000; // 100K milliseconds in the future
            let metadata = web3.utils.fromAscii(new String(13245678910)); // Random metadata in bytes32
            let bounty = web3.utils.toWei('1', 'ether');
 
            vulnerabilityRegistry = await RegistryTest.new({from: authority});           
            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, metadata, {from: researcher});
            contractId = tx.receipt.logs[0].args.contractId;

            await vulnerabilityRegistry.approve(timelock, contractId, true, {from: authority});
            await vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: bounty});
        });

        it("Should patch an acknowledged vulnerability", async function() {

            let tx = await vulnerabilityRegistry.patch(contractId, {from: vendor});
    
            // Test event fired
            truffleAssert.eventEmitted(tx, 'LogVulnerabilityPatch', (ev) => {                
                return (
                        ev.vendor === vendor 
                        );
            }, 'LogVulnerabilityPatch event did not fire with correct parameters');

            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status, STATUS.Patched, "Contract status should be Patched ("+STATUS.Patched+")");
        });

        it("Should NOT patch an approved vulnerability: contract is not in a Valid state", async function() {

            let bounty = web3.utils.toWei('1', 'ether');
   
            await vulnerabilityRegistry.setContract(contractId, researcher, vendor, REWARDSTATE.NULL, 0,
                                                STATUS.Invalid, // <- status, Input breaking the condition (to check)
                                                web3.utils.fromAscii("a"), 0, 0, "");

            await truffleAssert.fails(
                vulnerabilityRegistry.patch(contractId, {from: vendor}),
                "The vulnerability has not been acknowledged" // String of the revert
            );
        });

        // TODO test to store the patch data, if needed
    });


    describe("Testing approve()", function() {

        let contractId;
        let vulnerabilityRegistry;
        let secret = 123;
        let hashlock = web3.utils.soliditySha3({type: 'uint', value: secret});

        beforeEach(async function() {

            let date = new Date();
            let timelock = date.getTime() + 100000; // 100K milliseconds in the future
            let metadata = web3.utils.fromAscii(new String(13245678910)); // Random metadata in bytes32
            let bounty = web3.utils.toWei('1', 'ether');
 
            vulnerabilityRegistry = await RegistryTest.new({from: authority});           
            let tx = await vulnerabilityRegistry.newVulnerability(vendor, hashlock, metadata, {from: researcher});
            contractId = tx.receipt.logs[0].args.contractId;

            await vulnerabilityRegistry.approve(timelock, contractId, true, {from: authority});
            await vulnerabilityRegistry.acknowledge(contractId, bounty, {from: vendor, value: bounty});
            await vulnerabilityRegistry.patch(contractId, {from: vendor});
        });

        it("Should disclose the vulnerability: i) A patch has been provided", async function() {

            let tx = await vulnerabilityRegistry.disclose(contractId, secret, {from: researcher});
    
            // Test event fired
            truffleAssert.eventEmitted(tx, 'LogVulnerabilityDisclose', (ev) => {                
                return (
                        ev.communicator === researcher 
                        );
            }, 'LogVulnerabilityDisclose event did not fire with correct parameters');

            truffleAssert.eventEmitted(tx, 'LogVulnerabilitySecret', (ev) => {                
                return (
                        ev.secret === secret 
                        );
            }, 'LogVulnerabilitySecret event did not fire with correct parameters');

            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status, STATUS.Disclosed, "Contract status should be Disclosed ("+STATUS.Disclosed+")");
            assert.equal(contractData.secret, secret, "Secret does not match");
            assert.equal(contractData.rewardState, REWARDSTATE.TOCLAIM, "Contract reward state should be TOCLAIM ("+REWARDSTATE.TOCLAIM+")");
        });

        it("Should disclose the vulnerability: ii) Grace period elpased, status: Valid", async function() {

            await vulnerabilityRegistry.setContract(contractId, researcher, vendor, REWARDSTATE.NULL, 0,
                                                STATUS.Valid, // <- status, valid input
                                                hashlock,
                                                0, // <- timelock, expired
                                                secret, "");

            let tx = await vulnerabilityRegistry.disclose(contractId, secret, {from: researcher});
    
            let contractData = await vulnerabilityRegistry.getContractById(contractId);
            assert.equal(contractData.status, STATUS.Disclosed, "Contract status should be Disclosed ("+STATUS.Disclosed+")");
            assert.equal(contractData.secret, secret, "Secret does not match");
        });

        // it("Should NOT patch an approved vulnerability: contract is not in a Valid state", async function() {

        //     let bounty = web3.utils.toWei('1', 'ether');
   
        //     await vulnerabilityRegistry.setContract(contractId, researcher, vendor, REWARDSTATE.NULL, 0,
        //                                         STATUS.Invalid, // <- status, Input breaking the condition (to check)
        //                                         web3.utils.fromAscii("a"), 0, 0, "");

        //     await truffleAssert.fails(
        //         vulnerabilityRegistry.patch(contractId, {from: vendor}),
        //         "The vulnerability has not been acknowledged" // String of the revert
        //     );
        // });

    });


});