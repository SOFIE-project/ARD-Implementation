pragma solidity ^0.6.0;

// Remix only
// import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title VulnerabilityRegistry
 *
 * @notice This contract supports responsible disclosure of vulnerabilities. For each vulnerability a state machine identifies the stage of the responsible disclosure process
 *
 */
contract VulnerabilityRegistry is Ownable {

    // Logs
    event LogVulnerabilityNew(
        bytes32 indexed contractId,
        address indexed researcher,
        address indexed vendor,
        bytes32 hashlock,
        bytes32 vulnerabilityHash
    );
    event LogVulnerabilityDuplicate(
        bytes32 indexed contractId,
        bytes32 vendorName,
        bytes32 productName,
        bytes32 productVersion,
        bytes32 vulnerabilityHash
    );

    event LogVulnerabilityApproval(
        bytes32 indexed contractId,
        uint timelock,
        Status status
    );
    event LogVulnerabilitySecret(bytes32 indexed contractId, uint secret);
    event LogVulnerabilityAcknowledgment(bytes32 indexed contractId, address indexed vendor, uint bounty);
    event LogVulnerabilityPatch(bytes32 indexed contractId, address indexed vendor);
    event LogVulnerabilityDisclose(bytes32 indexed contractId, address indexed communicator, string vulnerabilityLocation);
    // States

    enum Status {Pending, Invalid, Valid, Acknowledged, Patched, Disclosed}
    enum RewardState {NULL, SET, TOCLAIM, TOREFUND, SENT} // TODO evaluate if we need TOREFUND

    // Structs

    struct Reward {
        RewardState state;
        uint amount;
    }

    struct Metadata {
        address vendor;             // The address of the vendor
        bytes32 vendorName;         // The name of the vendor
        bytes32 productName;        // The name of the product
        bytes32 productVersion;     // The version of the product
        bytes32 vulnerabilityHash;  // The hash of the vulnerability information
    }

    struct VulnerabilityContract {
        Metadata metadata;              // Metadata info
        uint timestamp;                 // The timestamp of the creation of the vulnerability
        address payable researcher;     // Researcher address
        Reward reward;                  // The reward for this vulnerability
        Status status;                  // The status of the vulnerability
        bytes32 hashlock;               // Sha-2 sha256 the secret used as hashlock
        uint timelock;                  // UNIX timestamp seconds - locked UNTIL this time //deadline
        uint secret;                    // The secret
        string vulnerabilityLocation;   // A pointer to a location with the vulnerability information
    }

    // Maps
    mapping (bytes32 => VulnerabilityContract) Contracts; //mapping _contract_id => _vulnerability
    mapping (bytes32 => bytes32) HashData; // mapping vulnerability_hash => _contract_id

    // Modifiers

    modifier fundsSent() {
        require(msg.value > 0, "msg.value must be > 0");
        _;
    }
    modifier futureTimelock(uint _time) {
        // The timelock time is after the last blocktime (now).
        require(_time > now, "timelock time must be in the future");
        _;
    }
    modifier contractExists(bytes32 _contractId) {
        require(haveContract(_contractId), "contractId does not exist");
        _;
    }
    modifier hashlockMatches(bytes32 _contractId, uint _secret) {
        require(
            Contracts[_contractId].hashlock == keccak256(abi.encodePacked(_secret)),
            "Hashed secret and hashlock do not match"
        );
        _;
    }
    modifier disclosable(bytes32 _contractId) {
        // Check the condition to disclose a vulnerability
        require(isDisclosable(_contractId), "This contract cannot be discolsed");
        _;
    }
    modifier isValid(bytes32 _contractId) {
        // Check whether a contract is Valid, i.e. it has been approved
        require(Contracts[_contractId].status == Status.Valid, "Status is not Valid");
        _;
    }
    modifier isVendor(bytes32 _contractId) {
        require(Contracts[_contractId].metadata.vendor == msg.sender, "Sender is not the Vendor");
        _;
    }


    /**
     * @dev The resercher sets up a new vulnerability contract.
     *
     * @param _vendor The Vendor address, the owner of the vulnerable device
     * @param _hashlock The secret hash used also for the hashlock (sha-2 sha256).
     * @param _vendorName The name of the vendor
     * @param _productName The name of the product
     * @param _productVersion The version of the product
     * @param _vulnerabilityHash The hash of the vulnerability data
     *
     * @return contractId Id of the new contract. This is needed for subsequent calls.
     */
    function newVulnerability(address _vendor, bytes32 _hashlock,
                                bytes32 _vendorName, bytes32 _productName,
                                bytes32 _productVersion, bytes32 _vulnerabilityHash)
        external
        returns (bytes32 contractId)
    {
        // Create a new entry
        contractId = keccak256(
            abi.encodePacked(
                msg.sender,
                _vendor,
                _hashlock,
                _vulnerabilityHash
            )
        );

        // Reject if a contract already exists with the same parameters. The
        // sender must change one of these parameters to create a new distinct
        // contract.
        if (haveContract(contractId))
            revert("Contract already exists");

        // It the submission contains already the same vulnerability information hash, fire event and return the currently stored contract
        if (haveHashData(_vulnerabilityHash)) {
            contractId = HashData[_vulnerabilityHash];
            VulnerabilityContract memory c = Contracts[contractId];

            emit LogVulnerabilityDuplicate(contractId, 
                            c.metadata.vendorName,
                            c.metadata.productName,
                            c.metadata.productVersion,
                            _vulnerabilityHash);

            return contractId;
        }

        // Store the new vulnerability entry
        Reward memory reward = Reward({amount: 0, state: RewardState.NULL});
        Metadata memory metadata = Metadata({
                                        vendor: _vendor,
                                        vendorName: _vendorName,
                                        productName: _productName,
                                        productVersion: _productVersion,
                                        vulnerabilityHash: _vulnerabilityHash
                                    });

        // Create new vulnerability entry
        Contracts[contractId] = VulnerabilityContract({
            metadata: metadata,
            timestamp: now,
            researcher: msg.sender,
            reward: reward,
            hashlock: _hashlock,
            timelock: 0,
            vulnerabilityLocation: "",
            status: Status.Pending,
            secret: 0
        });

        // Associate the contract with the vulnerability metadata
        HashData[_vulnerabilityHash] = contractId;

        emit LogVulnerabilityNew(
            contractId,
            msg.sender,
            _vendor,
            _hashlock,
            _vulnerabilityHash
        );

        return contractId;
    }


    /**
     * @dev The authority approves the vulnerability contract and provides the lock terms.
     *
     * @param _timelock UNIX epoch seconds time that  lock expires at.
     * @param _contractId The condract identifier.
     * @param _approved The approval parameter.
     */
    function approve(uint _timelock, bytes32 _contractId, bool _approved)
        external
        onlyOwner()
        futureTimelock(_timelock)
        contractExists(_contractId)
    {
        VulnerabilityContract storage c = Contracts[_contractId];

        // Reject if the contract isn't aprroved (the verification is off chain)

        if (!_approved) {
            c.status = Status.Invalid;
        }
        else {
            c.timelock = _timelock;
            c.status = Status.Valid;
        }

         emit LogVulnerabilityApproval(
            _contractId,
            _timelock,
            c.status
        );
    }

    /**
     * @dev The vendor acknowledges the vulnerability and sends ETH as a reward for the researcher.
     *
     * @param _contractId The condract identifier.
     * @param _bounty The bounty ETH.
     */
    function acknowledge(bytes32 _contractId, uint _bounty) 
        external
        payable
        fundsSent()
        contractExists(_contractId)
        isValid(_contractId) 
        isVendor(_contractId) {

        VulnerabilityContract storage c = Contracts[_contractId];

        require(now < c.timelock, "The timelock has expired");
        require(msg.value == _bounty, "Value sent does not match the input bounty");

        c.status = Status.Acknowledged;
        c.reward.state = RewardState.SET;
        c.reward.amount = _bounty;

        emit LogVulnerabilityAcknowledgment(_contractId, msg.sender, _bounty);
    }

    /**
     * @dev The vendor provides a patch to the vulnerability.
     *
     * @param _contractId The condract identifier.
     */
    function patch(bytes32 _contractId) external contractExists(_contractId) isVendor(_contractId) {

        VulnerabilityContract storage c = Contracts[_contractId];

        require(c.status == Status.Acknowledged, "The vulnerability has not been acknowledged");

        c.status = Status.Patched;
        emit LogVulnerabilityPatch(_contractId, msg.sender);
    }


     /**
     * @dev Called by who knows the secret (the researcher or the authority).
     * This will allow the researcher to withdraw the bounty.
     *
     * @param _contractId Id of the VulnerabilityContract.
     * @param _secret The preimage of the hashlock
     */
    function disclose(bytes32 _contractId, uint _secret, string calldata _vulnerabilityLocation)
        external
        contractExists(_contractId)
        disclosable(_contractId)
        hashlockMatches(_contractId, _secret)
        
        returns (bool success)
    {

        VulnerabilityContract storage c = Contracts[_contractId];

        // Label the reward to TOCLAIM only if there is a reward
        // else keep the reward state to NULL (the vendor never acknowledged the vulnerability)
        if(c.reward.state == RewardState.SET && c.reward.amount > 0)
            c.reward.state = RewardState.TOCLAIM;
        
        c.secret = _secret;
        c.status = Status.Disclosed;
        c.vulnerabilityLocation = _vulnerabilityLocation;

        emit LogVulnerabilityDisclose(_contractId, msg.sender, _vulnerabilityLocation);
        emit LogVulnerabilitySecret(_contractId, _secret);
        success = true;
    }

     /**
     * @dev Withdraw the bounty 
     *
     * @param _contractId Id of the VulnerabilityContract.
     */
    function withdrawBounty(bytes32 _contractId) external {

        VulnerabilityContract storage c = Contracts[_contractId];

        require(c.reward.state == RewardState.TOCLAIM, "Cannot claim reward yet");
        require(msg.sender == c.researcher, "Only the original researcher can withdraw the reward");

        c.reward.state = RewardState.SENT;
        c.researcher.transfer(c.reward.amount);
    }

    /**
     * @notice Get contract details.
     * @dev Need to split in two functions to avoid stack too deep exc
     * @param _contractId contract id
     */
    function getContractById(bytes32 _contractId)
        public
        view
        returns (
            address payable researcher,
            uint timestamp,
            RewardState rewardState,
            uint rewardAmount,
            Status status,
            bytes32 hashlock,
            uint timelock,
            uint secret,
            string memory vulnerabilityLocation
        )
    {
        if (haveContract(_contractId) == false)
            return (address(0), 0,
                    RewardState.NULL, 0, Status.Pending, 0x0, 0, 0, "");
        
        VulnerabilityContract storage c = Contracts[_contractId];
        return (
            c.researcher,
            c.timestamp,
            c.reward.state,
            c.reward.amount,
            c.status,
            c.hashlock,
            c.timelock,
            c.secret,
            c.vulnerabilityLocation
        );
    }

    /**
     * @notice Get the metadata of a vulnerability
     * @dev Need to split in two functions to avoid stack too deep exc
     * @param _contractId Id into contracts mapping.
     */
    function getMetadataById(bytes32 _contractId)
        public
        view
        returns (
            address vendor,
            bytes32 vendorName,         
            bytes32 productName,        
            bytes32 productVersion,     
            bytes32 vulnerabilityHash
        )
    {
        if (haveContract(_contractId) == false)
            return (address(0), 0x0, 0x0, 0x0, 0x0);
        
        VulnerabilityContract storage c = Contracts[_contractId];
        return (
            c.metadata.vendor,
            c.metadata.vendorName,
            c.metadata.productName,
            c.metadata.productVersion,
            c.metadata.vulnerabilityHash
        );
    }


    /**
     * @dev Is there a contract with id _contractId.
     * @param _contractId Id into contracts mapping.
     */
    function haveContract(bytes32 _contractId)
        internal
        view
        returns (bool exists)
    {
        exists = (Contracts[_contractId].researcher != address(0));
    }

    /**
     * @dev Is there a contract with meta _meta.
     * @param _hashData the hash of the vulnerability data
     */
    function haveHashData(bytes32 _hashData)
        internal
        view
        returns (bool exists)
    {
        exists = (HashData[_hashData] != 0x0);
    }

    /**
     * @dev Is the input contract disclosable
     * @param _contractId Contract identifier
     */
    function isDisclosable(bytes32 _contractId) public view returns(bool) {

        VulnerabilityContract storage c = Contracts[_contractId];
        return  ((c.status == Status.Valid || c.status == Status.Acknowledged) && c.timelock < now) ||
                (c.status == Status.Patched);

    }

}
