/*
 * SPDX-License-Identifier: Apache-2.0
 */

import crypto = require('crypto');
import { Context, Contract, Info, Returns, Transaction } from 'fabric-contract-api';
import { contracts } from '.';
import { Vulnerability } from './vulnerability';
const myCollectionName: string = 'CollectionOne';


// data-receiver.ts
type InterledgerEventAccepted = {
    Nonce: string;
};

type InterledgerEventRejected = {
    Nonce: string;
};


type DataItem = {
    Nonce: string;
    Data: string;
};
interface InterledgerReceiver{
    interledgerReceive(ctx: Context, nonce: string, vulnerabilityId: string, patchState: string):Promise<string>;// Function to receive data from Interledger
}
// data-sender.ts
type InterledgerEventSending = {
    Id: string;
    Data: string;
};

interface InterledgerSender{
    interledgerCommit(ctx: Context):Error;
    interledgerAbort(ctx: Context):Error;
}

@Info({title: 'VulnerabilityContract', description: 'My Private Data Smart Contract' })
export class VulnerabilityContract extends Contract implements InterledgerReceiver, InterledgerSender{

    @Transaction(false)
    @Returns('boolean')
    public async vulnerabilityExists(ctx: Context, vulnerabilityId: string): Promise<boolean> {
        const buffer: Buffer = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityId);
        return (!!buffer && buffer.length > 0);
    }

    @Transaction()
    public async createVulnerability(ctx: Context, vulnerabilityId: string): Promise<void> {
        const exists: boolean = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (exists) {
            throw new Error(`The asset vulnerability details ${vulnerabilityId} already exists`);
        }

        const privateAsset: Vulnerability = new Vulnerability();

        const transientData: Map<string, Buffer> = ctx.stub.getTransient();
        if (transientData.size === 0 || !transientData.has('vendorID')) {
            throw new Error('The vendorID key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorID = transientData.get('vendorID').toString('utf8');

        if (transientData.size === 0 || !transientData.has('vendorName')) {
            throw new Error('The vendorName key was not specified in transient data. Please try again.');
        }
        privateAsset.vendorName = transientData.get('vendorName').toString('utf8');

        if (transientData.size === 0 || !transientData.has('productName')) {
            throw new Error('The productName key was not specified in transient data. Please try again.');
        }
        privateAsset.productName = transientData.get('productName').toString('utf8');

        if (transientData.size === 0 || !transientData.has('vulnerabilityType')) {
            throw new Error('The vulnerabilityType key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilityType = transientData.get('vulnerabilityType').toString('utf8');

        if (transientData.size === 0 || !transientData.has('vulnerabilitySeverity')) {
            throw new Error('The vulnerabilitySeverity key was not specified in transient data. Please try again.');
        }
        privateAsset.vulnerabilitySeverity = transientData.get('vulnerabilitySeverity').toString('utf8');

        if (transientData.size === 0 || !transientData.has('patchState')) {
            throw new Error('The patchState key was not specified in transient data. Please try again.');
        }
        privateAsset.patchState = transientData.get('patchState').toString('utf8');

        if (transientData.size === 0 || !transientData.has('gracePeriod')) {
            throw new Error('The gracePeriod key was not specified in transient data. Please try again.');
        }
        privateAsset.gracePeriod = transientData.get('gracePeriod').toString('utf8');

        if (transientData.size === 0 || !transientData.has('bountyAmount')) {
            throw new Error('The bountyAmount key was not specified in transient data. Please try again.');
        }
        privateAsset.bountyAmount = transientData.get('bountyAmount').toString('utf8');

        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(privateAsset)));
    }

    @Transaction(false)
    @Returns('Vulnerability')
    public async readVulnerability(ctx: Context, vulnerabilityId: string): Promise<string> {
        const exists: boolean = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);
        }

        let privateDataString: string;
        const privateData: Buffer = await ctx.stub.getPrivateData(myCollectionName, vulnerabilityId);

        privateDataString = JSON.parse(privateData.toString());
        return privateDataString;
    }

    @Transaction()
    public async updateVulnerability(ctx: Context, vulnerabilityId: string, patchSt: string): Promise<void> {
        const exists: boolean = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);
        }
        // const privateData: Buffer = await ctx.stub.getPrivateData(myCollectionName, vulnerabilityId);
        // let privateDataString: string;
        // privateDataString = JSON.parse(privateData.toString());
        let privateAsset: Vulnerability = new Vulnerability();
        const result = this.readVulnerability(ctx, vulnerabilityId);
        privateAsset=JSON.parse(JSON.stringify(result));

        // const transientData: Map<string, Buffer> = ctx.stub.getTransient();
        // if (transientData.size === 0 || !transientData.has('privateValue')) {
        // throw new Error('The privateValue key was not specified in transient data. Please try again.');
        // }
        // privateAsset.privateValue = transientData.get('privateValue').toString('utf8');
        privateAsset.patchState=patchSt;
        console.log(privateAsset);
        await ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(privateAsset)));
    }

    @Transaction()
    public async deleteVulnerability(ctx: Context, vulnerabilityId: string): Promise<void> {
        const exists: boolean = await this.vulnerabilityExists(ctx, vulnerabilityId);
        if (!exists) {
            throw new Error(`The asset vulnerability ${vulnerabilityId} does not exist`);
        }
        await ctx.stub.deletePrivateData(myCollectionName, vulnerabilityId);
    }

    @Transaction()
    public async verifyVulnerability(ctx: Context, vulnerabilityId: string, objectToVerify: Vulnerability): Promise<boolean> {
        // Convert user provided object into a hash
        const hashToVerify: string = crypto.createHash('sha256').update(JSON.stringify(objectToVerify)).digest('hex');
        const pdHashBytes: Buffer = await ctx.stub.getPrivateDataHash(myCollectionName, vulnerabilityId);
        if (pdHashBytes.length === 0) {
            throw new Error(`No private data hash with the Key: ${vulnerabilityId}`);
        }

        const actualHash: string = pdHashBytes.toString('hex');

        // Compare the hash calculated (from object provided) and the hash stored on public ledger
        if (hashToVerify === actualHash) {
            return true;
        } else {
            return false;
        }
    }


    // data-sender.ts

    @Transaction(false)
    interledgerAbort(ctx:Context): Error{
        return null;
    }

    @Transaction(false)
    interledgerCommit(ctx:Context): Error{
        return null;
    }

    @Transaction()
    public async emitData(ctx:Context, data:Promise<string>): Promise<Error>{

        const id = JSON.stringify(ctx.stub.getState('id'));
        let id1 = parseInt(id,10);
        id1+=1;

        const iles : InterledgerEventSending ={
            Id : JSON.stringify(id1),
            Data: JSON.stringify(data)
        };

        ctx.stub.putState('id', Buffer.from(JSON.stringify(id1)));
        ctx.stub.setEvent('InterledgerEventSending', Buffer.from(JSON.stringify(iles)));

        return null;
    }

    // data-receiver.ts

    @Transaction()
    @Returns('Vulnerability')
    public async interledgerReceive(ctx: Context,nonceString: string, secretData: string):Promise<string> {

        // const args = this.newMethod(secretID);
        // let nonce_bytes=JSON.stringify(args[0]);
        // let secretID = args[1];
        const middle = Math.ceil(secretData.length / 2);
        const patchState = secretData.slice(0, middle);
        const vulnerabilityId = secretData.slice(middle);
        const res = this.vulnerabilityExists(ctx, vulnerabilityId);

        if(!res)
        {
            throw new Error('Invalid Secret');
        }
        const lastChar = patchState.substr(patchState.length-1);

        // let returnString:string = JSON.stringify(result);

        if(lastChar==='1')
        {
            // result=JSON.parse((JSON.stringify(result)).replace('"patchState":"Not Patched"','"patchState":"Patched"'));
            const ctx2: Context = this.createContext();
            this.updateVulnerability(ctx2, vulnerabilityId,'Patched');
            // ctx.stub.putPrivateData(myCollectionName, vulnerabilityId, Buffer.from(JSON.stringify(returnString))
        }
        // console.log(result);
        // console.dir(result.payload.toString('utf8'));
        // console.log(result.toString());
        // const returnValue: string = VulnerabilityContract.upload(result.toString());
        // const nonce = parseInt(nonceString, 64);
        let result = this.readVulnerability(ctx, vulnerabilityId);
        if(lastChar==='1')
        {
            result=JSON.parse((JSON.stringify(result)).replace('"patchState":"Not Patched"','"patchState":"Patched"'));
        }
        const nonce = nonceString;

        const dataItem : DataItem ={
            Nonce : nonce,
            Data: vulnerabilityId
        };

        // let items: Array<DataItem>;
        // items.push(dataItem);

        ctx.stub.putState('items',Buffer.from(JSON.stringify(dataItem)));
        ctx.stub.setEvent('InterledgerEventAccepted', Buffer.from(JSON.stringify(nonce)));

        this.emitData(ctx, result);

        return result;

    }


}
