pragma solidity ^0.6.0;

// Remix only

// import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol";
import "./VulnerabilityContract.sol";
import "./VendorDepositContract.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title VulnerabilityRegistry
 *
 * @notice This contract supports responsible disclosure of vulnerabilities. For each vulnerability a state machine identifies the stage of the responsible disclosure process
 *
 */
contract VulnerabilityRegistry is Ownable {

    // Logs
    event LogVulnerabilityNew(
        bytes32 indexed contractId,
        address indexed researcher,
        bytes32 vendorName,
        bytes32 hashlock,
        bytes32 vulnerabilityHash
    );

     event LogVulnerabilityDuplicate(
        bytes32 indexed contractId,
        bytes32 vendorName,
        bytes32 productName,
        bytes32 productVersion,
        bytes32 vulnerabilityHash,
        VulnerabilityContract.Status status
    );


    event vendorRegistered(address indexed vendor);
    event vendorDeregistered(address indexed vendor);
    event LogVulnerabilityApprove(bytes32 indexed contractId,uint timelock);
    event LogVulnerabilityReject(bytes32 indexed contractId);
    event LogVulnerabilitySecret(bytes32 indexed contractId, uint secret);
    event LogVulnerabilityAcknowledgment(bytes32 indexed contractId, address indexed vendor, uint bounty);
    event LogVulnerabilityPatch(bytes32 indexed contractId, address indexed vendor);
    event LogVulnerabilityDisclose(bytes32 indexed contractId, address indexed communicator, string vulnerabilityLocation);

    event LogContractById(
            address indexed researcher,
            uint timestamp,
            VulnerabilityContract.RewardStatus rewardStatus,
            uint rewardAmount,
            VulnerabilityContract.Status status,
            bytes32 hashlock,
            uint timelock,
            uint secret,
            string vulnerabilityLocation,
            address indexed vendor,
            bytes32 vendorName,
            bytes32 productName,
            bytes32 productVersion,
            bytes32 vulnerabilityHash
            );

    // Maps
    mapping(bytes32 => VulnerabilityContract) Contracts; //mapping _contract_id => _vulnerabilityContract
    mapping(bytes32 => bytes32) HashData; // mapping vulnerability_hash => _contract_id
    mapping(address => VendorDepositContract) public vendorContacts;// map vendor address to deposit vendor contract"
    mapping(address=> bytes32) public vendors;// map vendor address to vendor name"

    // Modifiers

     modifier onlyRegisteredVendors {
        require(vendors[msg.sender]!=0x0);
        _;
    }

    modifier fundsSent() {
        require(msg.value > 0, "msg.value must be > 0");
        _;
    }
    modifier futureTimelock(uint _time) {
        // The timelock time is after the last blocktime (now).
        require(_time > block.timestamp, "timelock time must be in the future");
        _;
    }
    modifier contractExists(bytes32 _contractId) {
        require(haveContract(_contractId), "contractId does not exist");
        _;
    }
    modifier hashlockMatches(bytes32 _contractId, uint _secret) {
        require(
            Contracts[_contractId].hashlock() == keccak256(abi.encodePacked(_secret)),
            "Hashed secret and hashlock do not match"
        );
        _;
    }
    modifier disclosable(bytes32 _contractId) {
        // Check the condition to disclose a vulnerability
        require(isDisclosable(_contractId), "This contract cannot be discolsed");
        _;
    }
    modifier isValid(bytes32 _contractId) {
        // Check whether a contract is Valid, i.e. it has been approved
        require(Contracts[_contractId].status() ==  VulnerabilityContract.Status.Valid, "Status is not Valid");
        _;
    }
    modifier isVendor(bytes32 _contractId) {
        require(Contracts[_contractId].vendorName() == vendors[msg.sender], "Sender is not the proper Vendor ");
        _;
    }

    /**
     * @dev The vendor registration. Authority is in charge to register the new vendor
     * and to deploy VendorDepositContract a VendorDepositContract for him.
     * Vendorss are mapped by name and address.
     * Only registerVendor can interact with the contract.
     *
     * @param _vendor The Vendor address
     * @param _vendorName The vendor name
     *
     */

    function registerVendor(address _vendor, bytes32 _vendorName) onlyOwner external {

        vendors[_vendor]=_vendorName;
        VendorDepositContract contractVendorAddress=new VendorDepositContract(payable(_vendor));
        vendorContacts[_vendor] = contractVendorAddress;

        emit vendorRegistered(_vendor);

    }

    function deregisterVendor(address _vendor) onlyOwner external {

        vendors[_vendor] =0x0;

        emit vendorDeregistered(_vendor);
    }

    /**
     * @dev The resercher sets up a new vulnerability contract.
     *
     * @param _hashlock The secret hash used also for the hashlock (sha-2 sha256).
     * @param _vendorName The name of the vendor
     * @param _productName The name of the product
     * @param _productVersion The version of the product
     * @param _vulnerabilityHash The hash of the vulnerability data
     *
     * @return contractId Id of the new contract. This is needed for subsequent calls.
     */
    function newVulnerability(bytes32 _hashlock,
                                bytes32 _vendorName, bytes32 _productName,
                                bytes32 _productVersion, bytes32 _vulnerabilityHash)
        external
        returns (bytes32 contractId)
    {
        // Create a new entry
        contractId = keccak256(
            abi.encodePacked(
                msg.sender,
                _vendorName,
                _hashlock,
                _vulnerabilityHash
            )
        );

        // Reject if a contract already exists with the same parameters. The
        // sender must change one of these parameters to create a new distinct
        // contract.
        if (haveContract(contractId))
            revert("Contract already exists");
        VulnerabilityContract contractAddress;

        // If the submission contains already the same vulnerability information hash, fire event and return the currently stored contract
        if (haveHashData(_vulnerabilityHash)) {
            contractId = HashData[_vulnerabilityHash];
            contractAddress = Contracts[contractId];

            emit LogVulnerabilityDuplicate(contractId,
                            contractAddress.vendorName(),
                            contractAddress.productName(),
                            contractAddress.productVersion(),
                            contractAddress.vulnerabilityHash(),
                            contractAddress.status());
            return contractId;
            }

        contractAddress=new VulnerabilityContract(
            msg.sender,
            _vendorName,
            _productName,
            _productVersion,
            _vulnerabilityHash,
            _hashlock
            );

        // Associate the contract with the vulnerability metadata
        Contracts[contractId]=contractAddress;
        HashData[_vulnerabilityHash] = contractId;

        emit LogVulnerabilityNew(
            contractId,
            msg.sender,
            _vendorName,
            _hashlock,
            _vulnerabilityHash
        );

        return contractId;

        }


    /**
     * @dev The authority approves the vulnerability contract and provides the lock terms.
     *
     * @param _timelock UNIX epoch seconds time that  lock expires at.
     * @param _contractId The condract identifier.
     * @param _approved The approval parameter.
     */
    function approve(uint _timelock, bytes32 _contractId, bool _approved)
        external
        onlyOwner()
        futureTimelock(_timelock)
        contractExists(_contractId)
    {
        VulnerabilityContract contractAddress = Contracts[_contractId];

        // Reject if the contract isn't approved (the verification is off chain)

        if (!_approved) {
            contractAddress.setStatus(VulnerabilityContract.Status.Invalid);

            emit LogVulnerabilityReject(_contractId);
        }
        else {
            contractAddress.setTimelock(_timelock);
            contractAddress.setStatus(VulnerabilityContract.Status.Valid);

            emit LogVulnerabilityApprove(_contractId,_timelock);
        }
    }

    /**
     * @dev The vendor acknowledges the vulnerability and sends ETH as a reward for the researcher.
     *
     * @param _contractId The condract identifier.
     * @param _bounty The bounty ETH.
     */
    function acknowledge (bytes32 _contractId, uint _bounty)
        external
        payable
        fundsSent()
        contractExists(_contractId)
        isValid(_contractId)
        isVendor(_contractId) {

        VulnerabilityContract contractAddress = Contracts[_contractId];
        VendorDepositContract contractDepositAddress = vendorContacts[msg.sender];

        require(block.timestamp < contractAddress.timelock(), "The timelock has expired");
        require(msg.value == _bounty, "Value sent does not match the input bounty");
        contractAddress.setVendor(msg.sender);
        contractAddress.setStatus(VulnerabilityContract.Status.Acknowledged);
        contractAddress.setRewardStatus(VulnerabilityContract.RewardStatus.SET);
        contractDepositAddress.registerBounty(address(contractAddress),_bounty);
        emit LogVulnerabilityAcknowledgment(_contractId, msg.sender, _bounty);
    }

    /**
     * @dev The vendor provides a patch to the vulnerability.
     *
     * @param _contractId The condract identifier.
     */
    function patch(bytes32 _contractId) external contractExists(_contractId) isVendor(_contractId) {

        VulnerabilityContract contractAddress = Contracts[_contractId];

        require(Contracts[_contractId].status()== VulnerabilityContract.Status.Acknowledged, "The vulnerability has not been acknowledged");

        contractAddress.setStatus(VulnerabilityContract.Status.Patched);
        emit LogVulnerabilityPatch(_contractId, msg.sender);
    }


     /**
     * @dev Called by who knows the secret (the researcher or the authority).
     * This will allow the researcher to withdraw the bounty.
     *
     * @param _contractId Id of the VulnerabilityContract.
     * @param _secret The preimage of the hashlock
     */
    function disclose(bytes32 _contractId, uint _secret, string calldata _vulnerabilityLocation)
        external
        contractExists(_contractId)
        disclosable(_contractId)
        hashlockMatches(_contractId, _secret)

        returns (bool success)
    {

        VulnerabilityContract contractAddress = Contracts[_contractId];
        VendorDepositContract vendorContractAddress = vendorContacts[contractAddress.vendor()];

        // Label the reward to TOCLAIM only if there is a reward
        // else keep the reward state to NULL (the vendor never acknowledged the vulnerability)
        if(contractAddress.rewStatus() ==VulnerabilityContract.RewardStatus.SET  && vendorContractAddress.balances(address(contractAddress)) > 0)
            contractAddress.setRewardStatus(VulnerabilityContract.RewardStatus.TOCLAIM);

        contractAddress.setSecret(_secret);
        contractAddress.setStatus(VulnerabilityContract.Status.Disclosed);
        contractAddress.setLocation(_vulnerabilityLocation);

        emit LogVulnerabilityDisclose(_contractId, msg.sender, _vulnerabilityLocation);
        emit LogVulnerabilitySecret(_contractId, _secret);
        success = true;
    }

     /**
     * @dev Withdraw the bounty
     *
     * @param _contractId Id of the VulnerabilityContract.
     */
    function withdrawBounty(bytes32 _contractId) external {

        VulnerabilityContract contractAddress = Contracts[_contractId];
        VendorDepositContract vendorContractAddress = vendorContacts[contractAddress.vendor()];

        require(contractAddress.rewStatus() == VulnerabilityContract.RewardStatus.TOCLAIM, "Cannot claim reward yet");
        require(msg.sender == contractAddress.researcher(), "Only the original researcher can withdraw the reward");

        contractAddress.setRewardStatus(VulnerabilityContract.RewardStatus.SENT);
        vendorContractAddress.payBounty(address(contractAddress));
    }

    /**
     * @notice Get contract details.
     * @dev Need to split in two functions to avoid stack too deep exc
     * @param _contractId contract id
     */
    function getContractById(bytes32 _contractId)
        public
    {
        if (haveContract(_contractId) == false)
            emit LogContractById(
                    address(0),
                    0,
                    VulnerabilityContract.RewardStatus.NULL,
                    0,
                    VulnerabilityContract.Status.Pending,
                    0x0,
                    0,
                    0,
                    "",
                    address(0),
                    0x0,
                    0x0,
                    0x0,
                    0x0);

        VulnerabilityContract contractAddress = Contracts[_contractId];
        VendorDepositContract vendorContractAddress = vendorContacts[contractAddress.vendor()];

        emit LogContractById(
            address(contractAddress.researcher()),
            contractAddress.timestamp(),
            contractAddress.rewStatus(),
            vendorContractAddress.balances(address(contractAddress)),
            contractAddress.status(),
            contractAddress.hashlock(),
            contractAddress.timelock(),
            contractAddress.secret(),
            contractAddress.vulnerabilityLocation(),
            contractAddress.vendor(),
            contractAddress.vendorName(),
            contractAddress.productName(),
            contractAddress.productVersion(),
            contractAddress.vulnerabilityHash()
        );
    }

    /**
     * @dev Is there a contract with id _contractId.
     * @param _contractId Id into contracts mapping.
     */
    function haveContract(bytes32 _contractId)
        internal
        view
        returns (bool exists)
    {
        exists = (address(Contracts[_contractId]) != address(0));
    }

    /**
     * @dev Is there a contract with meta _meta.
     * @param _hashData the hash of the vulnerability data
     */
    function haveHashData(bytes32 _hashData)
        internal
        view
        returns (bool exists)
    {
        exists = (HashData[_hashData] != 0x0);
    }

    /**
     * @dev Is the input contract disclosable
     * @param _contractId Contract identifier
     */
    function isDisclosable(bytes32 _contractId) public view returns(bool) {

        VulnerabilityContract contractAddress = Contracts[_contractId];
        return  ((contractAddress.status() == VulnerabilityContract.Status.Valid || contractAddress.status() ==VulnerabilityContract.Status.Acknowledged)
        && contractAddress.timelock() < block.timestamp) || (contractAddress.status() == VulnerabilityContract.Status.Patched);

    }

}
