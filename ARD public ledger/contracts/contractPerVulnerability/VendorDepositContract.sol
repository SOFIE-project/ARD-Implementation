pragma solidity ^0.6.0;

// import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol";
import "./VulnerabilityContract.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract VendorDepositContract is Ownable{

    constructor(address payable _vendor) public{
        vulnerabilityRegistry=msg.sender;
        transferOwnership(_vendor);
    }

    modifier onlyRegistry{
        require(msg.sender==vulnerabilityRegistry);
        _;
    }

    uint public totBalance;
    address public vulnerabilityRegistry;

    mapping(address=> uint ) public balances;

    function registerBounty(address _vulnerabilityAddress,uint _bounty) external onlyRegistry{

        require(balances[owner()]>_bounty);
        balances[owner()]-=_bounty;
        balances[_vulnerabilityAddress]=_bounty;
    }

    function cancelBounty(address _vulnerabilityAddress,string calldata reason) external onlyRegistry{
        uint amount=balances[_vulnerabilityAddress];
        balances[owner()]+=amount;
        balances[_vulnerabilityAddress]=0;
    }

    function payBounty(address _vulnerabilityAddress) external onlyRegistry{
        uint amount=balances[address(_vulnerabilityAddress)];
        VulnerabilityContract contractAddress = VulnerabilityContract(_vulnerabilityAddress) ;
        address payable researcher=contractAddress.researcher();
        researcher.transfer(amount);

    }

    function withdraw(uint _amount) external onlyOwner {
        require(balances[owner()]>_amount);
        payable(owner()).transfer(_amount);
    }

    fallback() external payable onlyOwner {
        totBalance+=msg.value;
        balances[owner()]+=msg.value;
    }
}
